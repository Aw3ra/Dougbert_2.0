[
    {
        "link": "https://docs.solana.com/developing/backwards-compatibility",
        "title": "backwards-compatibility",
        "content": "Backward Compatibility PolicyAs the Solana developer ecosystem grows, so does the need for clear expectations around\nbreaking API and behavior changes affecting applications and tooling built for Solana.\nIn a perfect world, Solana development could continue at a very fast pace without ever\ncausing issues for existing developers. However, some compromises will need to be made\nand so this document attempts to clarify and codify the process for new releases.\nExpectations\u200bSolana software releases include APIs, SDKs, and CLI tooling (with a few exceptions).\nSolana software releases follow semantic versioning, more details below.\nSoftware for a MINOR version release will be compatible across all software on the\nsame MAJOR version.\nDeprecation Process\u200bIn any PATCH or MINOR release, a feature, API, endpoint, etc. could be marked as deprecated.\nAccording to code upgrade difficulty, some features will be remain deprecated for a few release\ncycles.\nIn a future MAJOR release, deprecated features will be removed in an incompatible way.\nRelease Cadence\u200bThe Solana RPC API, Rust SDK, CLI tooling, and BPF Program SDK are all updated and shipped\nalong with each Solana software release and should always be compatible between PATCH\nupdates of a particular MINOR version release.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/backwards-compatibility",
        "title": "backwards-compatibility",
        "content": "Release Channels\u200bedge software that contains cutting-edge features with no backward compatibility policybeta software that runs on the Solana Testnet clusterstable software that run on the Solana Mainnet Beta and Devnet clustersMajor Releases (x.\n0.\n0)\u200bMAJOR version releases (e.\ng. 2.\n0.\n0) may contain breaking changes and removal of previously\ndeprecated features. Client SDKs and tooling will begin using new features and endpoints\nthat were enabled in the previous MAJOR version.\nMinor Releases (1.\nx.\n0)\u200bNew features and proposal implementations are added to new MINOR version\nreleases (e.\ng. 1.\n4.\n0) and are first run on Solana's Testnet cluster. While running\non the testnet, MINOR versions are considered to be in the beta release channel. After\nthose changes have been patched as needed and proven to be reliable, the MINOR version will\nbe upgraded to the stable release channel and deployed to the Mainnet Beta cluster.\nPatch Releases (1.\n0.\nx)\u200bLow risk features, non-breaking changes, and security and bug fixes are shipped as part\nof PATCH version releases (e.\ng. 1.\n0.\n11). Patches may be applied to both beta and stable\nrelease channels.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/backwards-compatibility",
        "title": "backwards-compatibility",
        "content": "RPC API\u200bPatch releases:Bug fixesSecurity fixesEndpoint / feature deprecationMinor releases:New RPC endpoints and featuresMajor releases:Removal of deprecated featuresRust Crates\u200bsolana-sdk - Rust SDK for creating transactions and parsing account statesolana-program - Rust SDK for writing programssolana-client - Rust client for connecting to RPC APIsolana-cli-config - Rust client for managing Solana CLI config filessolana-geyser-plugin-interface - Rust interface for developing Solana Geyser plugins.\nPatch releases:Bug fixesSecurity fixesPerformance improvementsMinor releases:New APIsMajor releasesRemoval of deprecated APIsBackwards incompatible behavior changesCLI Tools\u200bPatch releases:Bug and security fixesPerformance improvementsSubcommand / argument deprecationMinor releases:New subcommandsMajor releases:Switch to new RPC API endpoints / configuration introduced in the previous major version.\nRemoval of deprecated featuresRuntime Features\u200bNew Solana runtime features are feature-switched and manually activated. Runtime features\ninclude: the introduction of new native programs, sysvars, and syscalls; and changes to\ntheir behavior. Feature activation is cluster agnostic, allowing confidence to be built on\nTestnet before activation on Mainnet-beta.\nThe release process is as follows:New runtime feature is included in a new release, deactivated by defaultOnce sufficient staked validators upgrade to the new release, the runtime feature switch",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/backwards-compatibility",
        "title": "backwards-compatibility",
        "content": "is activated manually with an instructionThe feature takes effect at the beginning of the next epochInfrastructure Changes\u200bPublic API Nodes\u200bSolana provides publicly available RPC API nodes for all developers to use. The Solana team\nwill make their best effort to communicate any changes to the host, port, rate-limiting behavior,\navailability, etc. However, we recommend that developers rely on their own validator nodes to\ndiscourage dependence upon Solana operated nodes.\nLocal cluster scripts and Docker images\u200bBreaking changes will be limited to MAJOR version updates. MINOR and PATCH updates should always\nbe backwards compatible.\nExceptions\u200bWeb3 JavaScript SDK\u200bThe Web3.\nJS SDK also follows semantic versioning specifications but is shipped separately from Solana\nsoftware releases.\nAttack Vectors\u200bIf a new attack vector is discovered in existing code, the above processes may be\ncircumvented in order to rapidly deploy a fix, depending on the severity of the issue.\nCLI Tooling Output\u200bCLI tooling json output (output --json) compatibility will be preserved; however, output directed\nfor a human reader is subject to change. This includes output as well as potential help, warning, or\nerror messages.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-api",
        "title": "javascript-api",
        "content": "Web3 JavaScript APIWhat is Solana-Web3.\njs?\n\u200bThe Solana-Web3.\njs library aims to provide complete coverage of Solana. The library was built on top of the Solana JSON RPC API.\nYou can find the full documentation for the @solana/web3.\njs library here.\nCommon Terminology\u200bTermDefinitionProgramStateless executable code written to interpret instructions. Programs are capable of performing actions based on the instructions provided.\nInstructionThe smallest unit of a program that a client can include in a transaction. Within its processing code, an instruction may contain one or more cross-program invocations.\nTransactionOne or more instructions signed by the client using one or more Keypairs and executed atomically with only two possible outcomes: success or failure.\nFor the full list of terms, see Solana terminologyGetting Started\u200bInstallation\u200byarn\u200b$ yarn add @solana/web3.\njsnpm\u200b$ npm install --save @solana/web3.\njsBundle\u200b<!\n-- Development (un-minified) --><script src=\"https://unpkg.\ncom/@solana/web3.\njs@latest/lib/index.\niife.\njs\"></script><!\n-- Production (minified) --><script src=\"https://unpkg.\ncom/@solana/web3.\njs@latest/lib/index.\niife.\nmin.\njs\"></script>Usage\u200bJavascript\u200bconst solanaWeb3 = require(\"@solana/web3.\njs\");console.\nlog(solanaWeb3);ES6\u200bimport * as solanaWeb3 from \"@solana/web3.\njs\";console.\nlog(solanaWeb3);Browser Bundle\u200b// solanaWeb3 is provided in the global namespace by the bundle scriptconsole.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-api",
        "title": "javascript-api",
        "content": "log(solanaWeb3);Quickstart\u200bConnecting to a Wallet\u200bTo allow users to use your dApp or application on Solana, they will need to get access to their Keypair. A Keypair is a private key with a matching public key, used to sign transactions.\nThere are two ways to obtain a Keypair:Generate a new KeypairObtain a Keypair using the secret keyYou can obtain a new Keypair with the following:const { Keypair } = require(\"@solana/web3.\njs\");let keypair = Keypair.\ngenerate();This will generate a brand new Keypair for a user to fund and use within your application.\nYou can allow entry of the secretKey using a textbox, and obtain the Keypair with Keypair.\nfromSecretKey(secretKey).\nconst { Keypair } = require(\"@solana/web3.\njs\");let secretKey = Uint8Array.\nfrom([  202, 171, 192, 129, 150, 189, 204, 241, 142, 71, 205, 2, 81, 97, 2, 176, 48,  81, 45, 1, 96, 138, 220, 132, 231, 131, 120, 77, 66, 40, 97, 172, 91, 245, 84,  221, 157, 190, 9, 145, 176, 130, 25, 43, 72, 107, 190, 229, 75, 88, 191, 136,  7, 167, 109, 91, 170, 164, 186, 15, 142, 36, 12, 23,]);let keypair = Keypair.\nfromSecretKey(secretKey);Many wallets today allow users to bring their Keypair using a variety of extensions or web wallets. The general recommendation is to use wallets, not Keypairs, to sign transactions. The wallet creates a layer of separation between the dApp and the Keypair, ensuring that the dApp never has access to the secret key. You can find ways to connect to external wallets with the wallet-adapter library.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-api",
        "title": "javascript-api",
        "content": "Creating and Sending Transactions\u200bTo interact with programs on Solana, you create, sign, and send transactions to the network. Transactions are collections of instructions with signatures. The order that instructions exist in a transaction determines the order they are executed.\nA transaction in Solana-Web3.\njs is created using the Transaction object and adding desired messages, addresses, or instructions.\nTake the example of a transfer transaction:const {  Keypair,  Transaction,  SystemProgram,  LAMPORTS_PER_SOL,} = require(\"@solana/web3.\njs\");let fromKeypair = Keypair.\ngenerate();let toKeypair = Keypair.\ngenerate();let transaction = new Transaction();transaction.\nadd(  SystemProgram.\ntransfer({    fromPubkey: fromKeypair.\npublicKey,    toPubkey: toKeypair.\npublicKey,    lamports: LAMPORTS_PER_SOL,  }),);The above code achieves creating a transaction ready to be signed and broadcasted to the network. The SystemProgram.\ntransfer instruction was added to the transaction, containing the amount of lamports to send, and the to and from public keys.\nAll that is left is to sign the transaction with keypair and send it over the network. You can accomplish sending a transaction by using sendAndConfirmTransaction if you wish to alert the user or do something after a transaction is finished, or use sendTransaction if you don't need to wait for the transaction to be confirmed.\nconst {  sendAndConfirmTransaction,  clusterApiUrl,  Connection,} = require(\"@solana/web3.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-api",
        "title": "javascript-api",
        "content": "js\");let keypair = Keypair.\ngenerate();let connection = new Connection(clusterApiUrl(\"testnet\"));sendAndConfirmTransaction(connection, transaction, [keypair]);The above code takes in a TransactionInstruction using SystemProgram, creates a Transaction, and sends it over the network. You use Connection in order to define which Solana network you are connecting to, namely mainnet-beta, testnet, or devnet.\nInteracting with Custom Programs\u200bThe previous section visits sending basic transactions. In Solana everything you do interacts with different programs, including the previous section's transfer transaction. At the time of writing programs on Solana are either written in Rust or C.\nLet's look at the SystemProgram. The method signature for allocating space in your account on Solana in Rust looks like this:pub fn allocate(    pubkey: &Pubkey,    space: u64) -> InstructionIn Solana when you want to interact with a program you must first know all the accounts you will be interacting with.\nYou must always provide every account that the program will be interacting within the instruction. Not only that, but you must provide whether or not the account is isSigner or isWritable.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-api",
        "title": "javascript-api",
        "content": "In the allocate method above, a single account pubkey is required, as well as an amount of space for allocation. We know that the allocate method writes to the account by allocating space within it, making the pubkey required to be isWritable. isSigner is required when you are designating the account that is running the instruction. In this case, the signer is the account calling to allocate space within itself.\nLet's look at how to call this instruction using solana-web3.\njs:let keypair = web3.\nKeypair.\ngenerate();let payer = web3.\nKeypair.\ngenerate();let connection = new web3.\nConnection(web3.\nclusterApiUrl(\"testnet\"));let airdropSignature = await connection.\nrequestAirdrop(  payer.\npublicKey,  web3.\nLAMPORTS_PER_SOL,);await connection.\nconfirmTransaction({ signature: airdropSignature });First, we set up the account Keypair and connection so that we have an account to make allocate on the testnet. We also create a payer Keypair and airdrop some sol so we can pay for the allocate transaction.\nlet allocateTransaction = new web3.\nTransaction({  feePayer: payer.\npublicKey,});let keys = [{ pubkey: keypair.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-api",
        "title": "javascript-api",
        "content": "publicKey, isSigner: true, isWritable: true }];let params = { space: 100 };We create the transaction allocateTransaction, keys, and params objects. feePayer is an optional field when creating a transaction that specifies who is paying for the transaction, defaulting to the pubkey of the first signer in the transaction. keys represents all accounts that the program's allocate function will interact with. Since the allocate function also required space, we created params to be used later when invoking the allocate function.\nlet allocateStruct = {  index: 8,  layout: struct([u32(\"instruction\"), ns64(\"space\")]),};The above is created using u32 and ns64 from @solana/buffer-layout to facilitate the payload creation. The allocate function takes in the parameter space. To interact with the function we must provide the data as a Buffer format. The buffer-layout library helps with allocating the buffer and encoding it correctly for Rust programs on Solana to interpret.\nLet's break down this struct.\n{  index: 8, /* <-- */  layout: struct([    u32('instruction'),    ns64('space'),  ])}index is set to 8 because the function allocate is in the 8th position in the instruction enum for SystemProgram.\n/* https://github.\ncom/solana-labs/solana/blob/21bc43ed58c63c827ba4db30426965ef3e807180/sdk/program/src/system_instruction.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-api",
        "title": "javascript-api",
        "content": "rs#L142-L305 */pub enum SystemInstruction {    /** 0 **/CreateAccount {/**/},    /** 1 **/Assign {/**/},    /** 2 **/Transfer {/**/},    /** 3 **/CreateAccountWithSeed {/**/},    /** 4 **/AdvanceNonceAccount,    /** 5 **/WithdrawNonceAccount(u64),    /** 6 **/InitializeNonceAccount(Pubkey),    /** 7 **/AuthorizeNonceAccount(Pubkey),    /** 8 **/Allocate {/**/},    /** 9 **/AllocateWithSeed {/**/},    /** 10 **/AssignWithSeed {/**/},    /** 11 **/TransferWithSeed {/**/},    /** 12 **/UpgradeNonceAccount,}Next up is u32('instruction').\n{  index: 8,  layout: struct([    u32('instruction'), /* <-- */    ns64('space'),  ])}The layout in the allocate struct must always have u32('instruction') first when you are using it to call an instruction.\n{  index: 8,  layout: struct([    u32('instruction'),    ns64('space'), /* <-- */  ])}ns64('space') is the argument for the allocate function. You can see in the original allocate function in Rust that space was of the type u64. u64 is an unsigned 64bit integer. Javascript by default only provides up to 53bit integers. ns64 comes from @solana/buffer-layout to help with type conversions between Rust and Javascript. You can find more type conversions between Rust and Javascript at solana-labs/buffer-layout.\nlet data = Buffer.\nalloc(allocateStruct.\nlayout.\nspan);let layoutFields = Object.\nassign({ instruction: allocateStruct.\nindex }, params);allocateStruct.\nlayout.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-api",
        "title": "javascript-api",
        "content": "encode(layoutFields, data);Using the previously created bufferLayout, we can allocate a data buffer. We then assign our params { space: 100 } so that it maps correctly to the layout, and encode it to the data buffer. Now the data is ready to be sent to the program.\nallocateTransaction.\nadd(  new web3.\nTransactionInstruction({    keys,    programId: web3.\nSystemProgram.\nprogramId,    data,  }),);await web3.\nsendAndConfirmTransaction(connection, allocateTransaction, [  payer,  keypair,]);Finally, we add the transaction instruction with all the account keys, payer, data, and programId and broadcast the transaction to the network.\nThe full code can be found below.\nconst { struct, u32, ns64 } = require(\"@solana/buffer-layout\");const { Buffer } = require(\"buffer\");const web3 = require(\"@solana/web3.\njs\");let keypair = web3.\nKeypair.\ngenerate();let payer = web3.\nKeypair.\ngenerate();let connection = new web3.\nConnection(web3.\nclusterApiUrl(\"testnet\"));let airdropSignature = await connection.\nrequestAirdrop(  payer.\npublicKey,  web3.\nLAMPORTS_PER_SOL,);await connection.\nconfirmTransaction({ signature: airdropSignature });let allocateTransaction = new web3.\nTransaction({  feePayer: payer.\npublicKey,});let keys = [{ pubkey: keypair.\npublicKey, isSigner: true, isWritable: true }];let params = { space: 100 };let allocateStruct = {  index: 8,  layout: struct([u32(\"instruction\"), ns64(\"space\")]),};let data = Buffer.\nalloc(allocateStruct.\nlayout.\nspan);let layoutFields = Object.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-api",
        "title": "javascript-api",
        "content": "assign({ instruction: allocateStruct.\nindex }, params);allocateStruct.\nlayout.\nencode(layoutFields, data);allocateTransaction.\nadd(  new web3.\nTransactionInstruction({    keys,    programId: web3.\nSystemProgram.\nprogramId,    data,  }),);await web3.\nsendAndConfirmTransaction(connection, allocateTransaction, [  payer,  keypair,]);",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "Web3 API ReferenceWeb3 API Reference Guide\u200bThe @solana/web3.\njs library is a package that has coverage over the Solana JSON RPC API.\nYou can find the full documentation for the @solana/web3.\njs library here.\nGeneral\u200bConnection\u200bSource DocumentationConnection is used to interact with the Solana JSON RPC. You can use Connection to confirm transactions, get account info, and more.\nYou create a connection by defining the JSON RPC cluster endpoint and the desired commitment. Once this is complete, you can use this connection object to interact with any of the Solana JSON RPC API.\nExample Usage\u200bconst web3 = require(\"@solana/web3.\njs\");let connection = new web3.\nConnection(web3.\nclusterApiUrl(\"devnet\"), \"confirmed\");let slot = await connection.\ngetSlot();console.\nlog(slot);// 93186439let blockTime = await connection.\ngetBlockTime(slot);console.\nlog(blockTime);// 1630747045let block = await connection.\ngetBlock(slot);console.\nlog(block);/*{    blockHeight: null,    blockTime: 1630747045,    blockhash: 'AsFv1aV5DGip9YJHHqVjrGg6EKk55xuyxn2HeiN9xQyn',    parentSlot: 93186438,    previousBlockhash: '11111111111111111111111111111111',    rewards: [],    transactions: []}*/let slotLeader = await connection.\ngetSlotLeader();console.\nlog(slotLeader);//49AqLYbpJYc2DrzGUAH1fhWJy62yxBxpLEkfJwjKy2jrThe above example shows only a few of the methods on Connection. Please see the source generated docs for the full list.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "Transaction\u200bSourceDocumentationA transaction is used to interact with programs on the Solana blockchain. These transactions are constructed with TransactionInstructions, containing all the accounts possible to interact with, as well as any needed data or program addresses. Each TransactionInstruction consists of keys, data, and a programId. You can do multiple instructions in a single transaction, interacting with multiple programs at once.\nExample Usage\u200bconst web3 = require(\"@solana/web3.\njs\");const nacl = require(\"tweetnacl\");// Airdrop SOL for paying transactionslet payer = web3.\nKeypair.\ngenerate();let connection = new web3.\nConnection(web3.\nclusterApiUrl(\"devnet\"), \"confirmed\");let airdropSignature = await connection.\nrequestAirdrop(  payer.\npublicKey,  web3.\nLAMPORTS_PER_SOL,);await connection.\nconfirmTransaction({ signature: airdropSignature });let toAccount = web3.\nKeypair.\ngenerate();// Create Simple Transactionlet transaction = new web3.\nTransaction();// Add an instruction to executetransaction.\nadd(  web3.\nSystemProgram.\ntransfer({    fromPubkey: payer.\npublicKey,    toPubkey: toAccount.\npublicKey,    lamports: 1000,  }),);// Send and confirm transaction// Note: feePayer is by default the first signer, or payer, if the parameter is not setawait web3.\nsendAndConfirmTransaction(connection, transaction, [payer]);// Alternatively, manually construct the transactionlet recentBlockhash = await connection.\ngetRecentBlockhash();let manualTransaction = new web3.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "Transaction({  recentBlockhash: recentBlockhash.\nblockhash,  feePayer: payer.\npublicKey,});manualTransaction.\nadd(  web3.\nSystemProgram.\ntransfer({    fromPubkey: payer.\npublicKey,    toPubkey: toAccount.\npublicKey,    lamports: 1000,  }),);let transactionBuffer = manualTransaction.\nserializeMessage();let signature = nacl.\nsign.\ndetached(transactionBuffer, payer.\nsecretKey);manualTransaction.\naddSignature(payer.\npublicKey, signature);let isVerifiedSignature = manualTransaction.\nverifySignatures();console.\nlog(`The signatures were verifed: ${isVerifiedSignature}`);// The signatures were verified: truelet rawTransaction = manualTransaction.\nserialize();await web3.\nsendAndConfirmRawTransaction(connection, rawTransaction);Keypair\u200bSource DocumentationThe keypair is used to create an account with a public key and secret key within Solana. You can either generate, generate from a seed, or create from a secret key.\nExample Usage\u200bconst { Keypair } = require(\"@solana/web3.\njs\");let account = Keypair.\ngenerate();console.\nlog(account.\npublicKey.\ntoBase58());console.\nlog(account.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "secretKey);// 2DVaHtcdTf7cm18Zm9VV8rKK4oSnjmTkKE6MiXe18Qsb// Uint8Array(64) [//   152,  43, 116, 211, 207,  41, 220,  33, 193, 168, 118,//    24, 176,  83, 206, 132,  47, 194,   2, 203, 186, 131,//   197, 228, 156, 170, 154,  41,  56,  76, 159, 124,  18,//    14, 247,  32, 210,  51, 102,  41,  43,  21,  12, 170,//   166, 210, 195, 188,  60, 220, 210,  96, 136, 158,   6,//   205, 189, 165, 112,  32, 200, 116, 164, 234// ]let seed = Uint8Array.\nfrom([  70, 60, 102, 100, 70, 60, 102, 100, 70, 60, 102, 100, 70, 60, 102, 100, 70,  60, 102, 100, 70, 60, 102, 100, 70, 60, 102, 100, 70, 60, 102, 100,]);let accountFromSeed = Keypair.\nfromSeed(seed);console.\nlog(accountFromSeed.\npublicKey.\ntoBase58());console.\nlog(accountFromSeed.\nsecretKey);// 3LDverZtSC9Duw2wyGC1C38atMG49toPNW9jtGJiw9Ar// Uint8Array(64) [//    70,  60, 102, 100,  70,  60, 102, 100,  70,  60, 102,//   100,  70,  60, 102, 100,  70,  60, 102, 100,  70,  60,//   102, 100,  70,  60, 102, 100,  70,  60, 102, 100,  34,//   164,   6,  12,   9, 193, 196,  30, 148, 122, 175,  11,//    28, 243, 209,  82, 240, 184,  30,  31,  56, 223, 236,//   227,  60,  72, 215,  47, 208, 209, 162,  59// ]let accountFromSecret = Keypair.\nfromSecretKey(account.\nsecretKey);console.\nlog(accountFromSecret.\npublicKey.\ntoBase58());console.\nlog(accountFromSecret.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "secretKey);// 2DVaHtcdTf7cm18Zm9VV8rKK4oSnjmTkKE6MiXe18Qsb// Uint8Array(64) [//   152,  43, 116, 211, 207,  41, 220,  33, 193, 168, 118,//    24, 176,  83, 206, 132,  47, 194,   2, 203, 186, 131,//   197, 228, 156, 170, 154,  41,  56,  76, 159, 124,  18,//    14, 247,  32, 210,  51, 102,  41,  43,  21,  12, 170,//   166, 210, 195, 188,  60, 220, 210,  96, 136, 158,   6,//   205, 189, 165, 112,  32, 200, 116, 164, 234// ]Using generate generates a random Keypair for use as an account on Solana. Using fromSeed, you can generate a Keypair using a deterministic constructor. fromSecret creates a Keypair from a secret Uint8array. You can see that the publicKey for the generate Keypair and fromSecret Keypair are the same because the secret from the generate Keypair is used in fromSecret.\nWarning: Do not use fromSeed unless you are creating a seed with high entropy. Do not share your seed. Treat the seed like you would a private key.\nPublicKey\u200bSource DocumentationPublicKey is used throughout @solana/web3.\njs in transactions, keypairs, and programs. You require publickey when listing each account in a transaction and as a general identifier on Solana.\nA PublicKey can be created with a base58 encoded string, buffer, Uint8Array, number, and an array of numbers.\nExample Usage\u200bconst { Buffer } = require(\"buffer\");const web3 = require(\"@solana/web3.\njs\");const crypto = require(\"crypto\");// Create a PublicKey with a base58 encoded stringlet base58publicKey = new web3.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "PublicKey(  \"5xot9PVkphiX2adznghwrAuxGs2zeWisNSxMW6hU6Hkj\",);console.\nlog(base58publicKey.\ntoBase58());// 5xot9PVkphiX2adznghwrAuxGs2zeWisNSxMW6hU6Hkj// Create a Program Addresslet highEntropyBuffer = crypto.\nrandomBytes(31);let programAddressFromKey = await web3.\nPublicKey.\ncreateProgramAddress(  [highEntropyBuffer.\nslice(0, 31)],  base58publicKey,);console.\nlog(`Generated Program Address: ${programAddressFromKey.\ntoBase58()}`);// Generated Program Address: 3thxPEEz4EDWHNxo1LpEpsAxZryPAHyvNVXJEJWgBgwJ// Find Program address given a PublicKeylet validProgramAddress = await web3.\nPublicKey.\nfindProgramAddress(  [Buffer.\nfrom(\"\", \"utf8\")],  programAddressFromKey,);console.\nlog(`Valid Program Address: ${validProgramAddress}`);// Valid Program Address: C14Gs3oyeXbASzwUpqSymCKpEyccfEuSe8VRar9vJQRE,253SystemProgram\u200bSourceDocumentationThe SystemProgram grants the ability to create accounts, allocate account data, assign an account to programs, work with nonce accounts, and transfer lamports. You can use the SystemInstruction class to help with decoding and reading individual instructionsExample Usage\u200bconst web3 = require(\"@solana/web3.\njs\");// Airdrop SOL for paying transactionslet payer = web3.\nKeypair.\ngenerate();let connection = new web3.\nConnection(web3.\nclusterApiUrl(\"devnet\"), \"confirmed\");let airdropSignature = await connection.\nrequestAirdrop(  payer.\npublicKey,  web3.\nLAMPORTS_PER_SOL,);await connection.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "confirmTransaction({ signature: airdropSignature });// Allocate Account Datalet allocatedAccount = web3.\nKeypair.\ngenerate();let allocateInstruction = web3.\nSystemProgram.\nallocate({  accountPubkey: allocatedAccount.\npublicKey,  space: 100,});let transaction = new web3.\nTransaction().\nadd(allocateInstruction);await web3.\nsendAndConfirmTransaction(connection, transaction, [  payer,  allocatedAccount,]);// Create Nonce Accountlet nonceAccount = web3.\nKeypair.\ngenerate();let minimumAmountForNonceAccount =  await connection.\ngetMinimumBalanceForRentExemption(web3.\nNONCE_ACCOUNT_LENGTH);let createNonceAccountTransaction = new web3.\nTransaction().\nadd(  web3.\nSystemProgram.\ncreateNonceAccount({    fromPubkey: payer.\npublicKey,    noncePubkey: nonceAccount.\npublicKey,    authorizedPubkey: payer.\npublicKey,    lamports: minimumAmountForNonceAccount,  }),);await web3.\nsendAndConfirmTransaction(  connection,  createNonceAccountTransaction,  [payer, nonceAccount],);// Advance nonce - Used to create transactions as an account custodianlet advanceNonceTransaction = new web3.\nTransaction().\nadd(  web3.\nSystemProgram.\nnonceAdvance({    noncePubkey: nonceAccount.\npublicKey,    authorizedPubkey: payer.\npublicKey,  }),);await web3.\nsendAndConfirmTransaction(connection, advanceNonceTransaction, [  payer,]);// Transfer lamports between accountslet toAccount = web3.\nKeypair.\ngenerate();let transferTransaction = new web3.\nTransaction().\nadd(  web3.\nSystemProgram.\ntransfer({    fromPubkey: payer.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "publicKey,    toPubkey: toAccount.\npublicKey,    lamports: 1000,  }),);await web3.\nsendAndConfirmTransaction(connection, transferTransaction, [payer]);// Assign a new account to a programlet programId = web3.\nKeypair.\ngenerate();let assignedAccount = web3.\nKeypair.\ngenerate();let assignTransaction = new web3.\nTransaction().\nadd(  web3.\nSystemProgram.\nassign({    accountPubkey: assignedAccount.\npublicKey,    programId: programId.\npublicKey,  }),);await web3.\nsendAndConfirmTransaction(connection, assignTransaction, [  payer,  assignedAccount,]);Secp256k1Program\u200bSource DocumentationThe Secp256k1Program is used to verify Secp256k1 signatures, which are used by both Bitcoin and Ethereum.\nExample Usage\u200bconst { keccak_256 } = require(\"js-sha3\");const web3 = require(\"@solana/web3.\njs\");const secp256k1 = require(\"secp256k1\");// Create a Ethereum Address from secp256k1let secp256k1PrivateKey;do {  secp256k1PrivateKey = web3.\nKeypair.\ngenerate().\nsecretKey.\nslice(0, 32);} while (!\nsecp256k1.\nprivateKeyVerify(secp256k1PrivateKey));let secp256k1PublicKey = secp256k1  .\npublicKeyCreate(secp256k1PrivateKey, false)  .\nslice(1);let ethAddress =  web3.\nSecp256k1Program.\npublicKeyToEthAddress(secp256k1PublicKey);console.\nlog(`Ethereum Address: 0x${ethAddress.\ntoString(\"hex\")}`);// Ethereum Address: 0xadbf43eec40694eacf36e34bb5337fba6a2aa8ee// Fund a keypair to create instructionslet fromPublicKey = web3.\nKeypair.\ngenerate();let connection = new web3.\nConnection(web3.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "clusterApiUrl(\"devnet\"), \"confirmed\");let airdropSignature = await connection.\nrequestAirdrop(  fromPublicKey.\npublicKey,  web3.\nLAMPORTS_PER_SOL,);await connection.\nconfirmTransaction({ signature: airdropSignature });// Sign Message with Ethereum Keylet plaintext = Buffer.\nfrom(\"string address\");let plaintextHash = Buffer.\nfrom(keccak_256.\nupdate(plaintext).\ndigest());let { signature, recid: recoveryId } = secp256k1.\necdsaSign(  plaintextHash,  secp256k1PrivateKey,);// Create transaction to verify the signaturelet transaction = new Transaction().\nadd(  web3.\nSecp256k1Program.\ncreateInstructionWithEthAddress({    ethAddress: ethAddress.\ntoString(\"hex\"),    plaintext,    signature,    recoveryId,  }),);// Transaction will succeed if the message is verified to be signed by the addressawait web3.\nsendAndConfirmTransaction(connection, transaction, [fromPublicKey]);Message\u200bSource DocumentationMessage is used as another way to construct transactions. You can construct a message using the accounts, header, instructions, and recentBlockhash that are a part of a transaction. A Transaction is a Message plus the list of required signatures required to execute the transaction.\nExample Usage\u200bconst { Buffer } = require(\"buffer\");const bs58 = require(\"bs58\");const web3 = require(\"@solana/web3.\njs\");let toPublicKey = web3.\nKeypair.\ngenerate().\npublicKey;let fromPublicKey = web3.\nKeypair.\ngenerate();let connection = new web3.\nConnection(web3.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "clusterApiUrl(\"devnet\"), \"confirmed\");let airdropSignature = await connection.\nrequestAirdrop(  fromPublicKey.\npublicKey,  web3.\nLAMPORTS_PER_SOL,);await connection.\nconfirmTransaction({ signature: airdropSignature });let type = web3.\nSYSTEM_INSTRUCTION_LAYOUTS.\nTransfer;let data = Buffer.\nalloc(type.\nlayout.\nspan);let layoutFields = Object.\nassign({ instruction: type.\nindex });type.\nlayout.\nencode(layoutFields, data);let recentBlockhash = await connection.\ngetRecentBlockhash();let messageParams = {  accountKeys: [    fromPublicKey.\npublicKey.\ntoString(),    toPublicKey.\ntoString(),    web3.\nSystemProgram.\nprogramId.\ntoString(),  ],  header: {    numReadonlySignedAccounts: 0,    numReadonlyUnsignedAccounts: 1,    numRequiredSignatures: 1,  },  instructions: [    {      accounts: [0, 1],      data: bs58.\nencode(data),      programIdIndex: 2,    },  ],  recentBlockhash,};let message = new web3.\nMessage(messageParams);let transaction = web3.\nTransaction.\npopulate(message, [  fromPublicKey.\npublicKey.\ntoString(),]);await web3.\nsendAndConfirmTransaction(connection, transaction, [fromPublicKey]);Struct\u200bSourceDocumentationThe struct class is used to create Rust compatible structs in javascript. This class is only compatible with Borsh encoded Rust structs.\nExample Usage\u200bStruct in Rust:pub struct Fee {    pub denominator: u64,    pub numerator: u64,}Using web3:import BN from \"bn.\njs\";import { Struct } from \"@solana/web3.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "js\";export class Fee extends Struct {  denominator: BN;  numerator: BN;}Enum\u200bSource DocumentationThe Enum class is used to represent a Rust compatible Enum in javascript. The enum will just be a string representation if logged but can be properly encoded/decoded when used in conjunction with Struct. This class is only compatible with Borsh encoded Rust enumerations.\nExample Usage\u200bRust:pub enum AccountType {    Uninitialized,    StakePool,    ValidatorList,}Web3:import { Enum } from \"@solana/web3.\njs\";export class AccountType extends Enum {}NonceAccount\u200bSource DocumentationNormally a transaction is rejected if a transaction's recentBlockhash field is too old. To provide for certain custodial services, Nonce Accounts are used. Transactions which use a recentBlockhash captured on-chain by a Nonce Account do not expire as long at the Nonce Account is not advanced.\nYou can create a nonce account by first creating a normal account, then using SystemProgram to make the account a Nonce Account.\nExample Usage\u200bconst web3 = require(\"@solana/web3.\njs\");// Create connectionlet connection = new web3.\nConnection(web3.\nclusterApiUrl(\"devnet\"), \"confirmed\");// Generate accountslet account = web3.\nKeypair.\ngenerate();let nonceAccount = web3.\nKeypair.\ngenerate();// Fund accountlet airdropSignature = await connection.\nrequestAirdrop(  account.\npublicKey,  web3.\nLAMPORTS_PER_SOL,);await connection.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "confirmTransaction({ signature: airdropSignature });// Get Minimum amount for rent exemptionlet minimumAmount = await connection.\ngetMinimumBalanceForRentExemption(  web3.\nNONCE_ACCOUNT_LENGTH,);// Form CreateNonceAccount transactionlet transaction = new web3.\nTransaction().\nadd(  web3.\nSystemProgram.\ncreateNonceAccount({    fromPubkey: account.\npublicKey,    noncePubkey: nonceAccount.\npublicKey,    authorizedPubkey: account.\npublicKey,    lamports: minimumAmount,  }),);// Create Nonce Accountawait web3.\nsendAndConfirmTransaction(connection, transaction, [  account,  nonceAccount,]);let nonceAccountData = await connection.\ngetNonce(  nonceAccount.\npublicKey,  \"confirmed\",);console.\nlog(nonceAccountData);// NonceAccount {//   authorizedPubkey: PublicKey {//     _bn: <BN: 919981a5497e8f85c805547439ae59f607ea625b86b1138ea6e41a68ab8ee038>//   },//   nonce: '93zGZbhMmReyz4YHXjt2gHsvu5tjARsyukxD4xnaWaBq',//   feeCalculator: { lamportsPerSignature: 5000 }// }let nonceAccountInfo = await connection.\ngetAccountInfo(  nonceAccount.\npublicKey,  \"confirmed\",);let nonceAccountFromInfo = web3.\nNonceAccount.\nfromAccountData(  nonceAccountInfo.\ndata,);console.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "log(nonceAccountFromInfo);// NonceAccount {//   authorizedPubkey: PublicKey {//     _bn: <BN: 919981a5497e8f85c805547439ae59f607ea625b86b1138ea6e41a68ab8ee038>//   },//   nonce: '93zGZbhMmReyz4YHXjt2gHsvu5tjARsyukxD4xnaWaBq',//   feeCalculator: { lamportsPerSignature: 5000 }// }The above example shows both how to create a NonceAccount using SystemProgram.\ncreateNonceAccount, as well as how to retrieve the NonceAccount from accountInfo. Using the nonce, you can create transactions offline with the nonce in place of the recentBlockhash.\nVoteAccount\u200bSourceDocumentationVote account is an object that grants the capability of decoding vote accounts from the native vote account program on the network.\nExample Usage\u200bconst web3 = require(\"@solana/web3.\njs\");let voteAccountInfo = await connection.\ngetProgramAccounts(web3.\nVOTE_PROGRAM_ID);let voteAccountFromData = web3.\nVoteAccount.\nfromAccountData(  voteAccountInfo[0].\naccount.\ndata,);console.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "log(voteAccountFromData);/*VoteAccount {  nodePubkey: PublicKey {    _bn: <BN: cf1c635246d4a2ebce7b96bf9f44cacd7feed5552be3c714d8813c46c7e5ec02>  },  authorizedWithdrawer: PublicKey {    _bn: <BN: b76ae0caa56f2b9906a37f1b2d4f8c9d2a74c1420cd9eebe99920b364d5cde54>  },  commission: 10,  rootSlot: 104570885,  votes: [    { slot: 104570886, confirmationCount: 31 },    { slot: 104570887, confirmationCount: 30 },    { slot: 104570888, confirmationCount: 29 },    { slot: 104570889, confirmationCount: 28 },    { slot: 104570890, confirmationCount: 27 },    { slot: 104570891, confirmationCount: 26 },    { slot: 104570892, confirmationCount: 25 },    { slot: 104570893, confirmationCount: 24 },    { slot: 104570894, confirmationCount: 23 },    .\n.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": ".  ],  authorizedVoters: [ { epoch: 242, authorizedVoter: [PublicKey] } ],  priorVoters: [      [Object], [Object], [Object],      [Object], [Object], [Object],      [Object], [Object], [Object],      [Object], [Object], [Object],      [Object], [Object], [Object],      [Object], [Object], [Object],      [Object], [Object], [Object],      [Object], [Object], [Object],      [Object], [Object], [Object],      [Object], [Object], [Object],      [Object], [Object]   ],  epochCredits: [    { epoch: 179, credits: 33723163, prevCredits: 33431259 },    { epoch: 180, credits: 34022643, prevCredits: 33723163 },    { epoch: 181, credits: 34331103, prevCredits: 34022643 },    { epoch: 182, credits: 34619348, prevCredits: 34331103 },    { epoch: 183, credits: 34880375, prevCredits: 34619348 },    { epoch: 184, credits: 35074055, prevCredits: 34880375 },    { epoch: 185, credits: 35254965, prevCredits: 35074055 },    { epoch: 186, credits: 35437863, prevCredits: 35254965 },    { epoch: 187, credits: 35672671, prevCredits: 35437863 },    { epoch: 188, credits: 35950286, prevCredits: 35672671 },    { epoch: 189, credits: 36228439, prevCredits: 35950286 },    .\n.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": ".  ],  lastTimestamp: { slot: 104570916, timestamp: 1635730116 }}*/Staking\u200bStakeProgram\u200bSourceDocumentationThe StakeProgram facilitates staking SOL and delegating them to any validators on the network. You can use StakeProgram to create a stake account, stake some SOL, authorize accounts for withdrawal of your stake, deactivate your stake, and withdraw your funds. The StakeInstruction class is used to decode and read more instructions from transactions calling the StakeProgramExample Usage\u200bconst web3 = require(\"@solana/web3.\njs\");// Fund a key to create transactionslet fromPublicKey = web3.\nKeypair.\ngenerate();let connection = new web3.\nConnection(web3.\nclusterApiUrl(\"devnet\"), \"confirmed\");let airdropSignature = await connection.\nrequestAirdrop(  fromPublicKey.\npublicKey,  web3.\nLAMPORTS_PER_SOL,);await connection.\nconfirmTransaction({ signature: airdropSignature });// Create Accountlet stakeAccount = web3.\nKeypair.\ngenerate();let authorizedAccount = web3.\nKeypair.\ngenerate();/* Note: This is the minimum amount for a stake account -- Add additional Lamports for staking    For example, we add 50 lamports as part of the stake */let lamportsForStakeAccount =  (await connection.\ngetMinimumBalanceForRentExemption(    web3.\nStakeProgram.\nspace,  )) + 50;let createAccountTransaction = web3.\nStakeProgram.\ncreateAccount({  fromPubkey: fromPublicKey.\npublicKey,  authorized: new web3.\nAuthorized(    authorizedAccount.\npublicKey,    authorizedAccount.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "publicKey,  ),  lamports: lamportsForStakeAccount,  lockup: new web3.\nLockup(0, 0, fromPublicKey.\npublicKey),  stakePubkey: stakeAccount.\npublicKey,});await web3.\nsendAndConfirmTransaction(connection, createAccountTransaction, [  fromPublicKey,  stakeAccount,]);// Check that stake is availablelet stakeBalance = await connection.\ngetBalance(stakeAccount.\npublicKey);console.\nlog(`Stake balance: ${stakeBalance}`);// Stake balance: 2282930// We can verify the state of our stake. This may take some time to become activelet stakeState = await connection.\ngetStakeActivation(stakeAccount.\npublicKey);console.\nlog(`Stake state: ${stakeState.\nstate}`);// Stake state: inactive// To delegate our stake, we get the current vote accounts and choose the firstlet voteAccounts = await connection.\ngetVoteAccounts();let voteAccount = voteAccounts.\ncurrent.\nconcat(voteAccounts.\ndelinquent)[0];let votePubkey = new web3.\nPublicKey(voteAccount.\nvotePubkey);// We can then delegate our stake to the voteAccountlet delegateTransaction = web3.\nStakeProgram.\ndelegate({  stakePubkey: stakeAccount.\npublicKey,  authorizedPubkey: authorizedAccount.\npublicKey,  votePubkey: votePubkey,});await web3.\nsendAndConfirmTransaction(connection, delegateTransaction, [  fromPublicKey,  authorizedAccount,]);// To withdraw our funds, we first have to deactivate the stakelet deactivateTransaction = web3.\nStakeProgram.\ndeactivate({  stakePubkey: stakeAccount.\npublicKey,  authorizedPubkey: authorizedAccount.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "publicKey,});await web3.\nsendAndConfirmTransaction(connection, deactivateTransaction, [  fromPublicKey,  authorizedAccount,]);// Once deactivated, we can withdraw our fundslet withdrawTransaction = web3.\nStakeProgram.\nwithdraw({  stakePubkey: stakeAccount.\npublicKey,  authorizedPubkey: authorizedAccount.\npublicKey,  toPubkey: fromPublicKey.\npublicKey,  lamports: stakeBalance,});await web3.\nsendAndConfirmTransaction(connection, withdrawTransaction, [  fromPublicKey,  authorizedAccount,]);Authorized\u200bSource DocumentationAuthorized is an object used when creating an authorized account for staking within Solana. You can designate a staker and withdrawer separately, allowing for a different account to withdraw other than the staker.\nYou can find more usage of the Authorized object under StakeProgramLockup\u200bSource DocumentationLockup is used in conjunction with the StakeProgram to create an account. The Lockup is used to determine how long the stake will be locked, or unable to be retrieved. If the Lockup is set to 0 for both epoch and the Unix timestamp, the lockup will be disabled for the stake account.\nExample Usage\u200bconst {  Authorized,  Keypair,  Lockup,  StakeProgram,} = require(\"@solana/web3.\njs\");let account = Keypair.\ngenerate();let stakeAccount = Keypair.\ngenerate();let authorized = new Authorized(account.\npublicKey, account.\npublicKey);let lockup = new Lockup(0, 0, account.\npublicKey);let createStakeAccountInstruction = StakeProgram.\ncreateAccount({  fromPubkey: account.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/javascript-reference",
        "title": "javascript-reference",
        "content": "publicKey,  authorized: authorized,  lamports: 1000,  lockup: lockup,  stakePubkey: stakeAccount.\npublicKey,});The above code creates a createStakeAccountInstruction to be used when creating an account with the StakeProgram. The Lockup is set to 0 for both the epoch and Unix timestamp, disabling lockup for the account.\nSee StakeProgram for more.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/clients/rust-api",
        "title": "rust-api",
        "content": "Rust APISolana's Rust crates are published to crates.\nio and can be found\non docs.\nrs with the \"solana-\" prefix.\nSome important crates:solana-program \u2014 Imported by programs running on Solana, compiled\nto BPF. This crate contains many fundamental data types and is re-exported from\nsolana-sdk, which cannot be imported from a Solana program.\nsolana-sdk \u2014 The basic off-chain SDK, it re-exports\nsolana-program and adds more APIs on top of that. Most Solana programs\nthat do not run on-chain will import this.\nsolana-client \u2014 For interacting with a Solana node via the\nJSON RPC API.\nsolana-cli-config \u2014 Loading and saving the Solana CLI configuration\nfile.\nsolana-clap-utils \u2014 Routines for setting up a CLI, using clap,\nas used by the main Solana CLI. Includes functions for loading all types of\nsigners supported by the CLI.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "Creating Compressed NFTs with JavaScriptCompressed NFTs on Solana use the\nBubblegum program from\nMetaplex to cheaply and securely store NFT metadata using\nState Compression.\nThis developer guide will use JavaScript/TypeScript to demonstrate:how to create a tree for compressed NFTs,how to mint compressed NFTs into a tree,how to get compressed NFT metadata from the Read API,\nandhow to transfer compressed NFTsIntro to Compressed NFTs\u200bCompressed NFTs use State Compression and\nmerkle trees to\ndrastically reduce the storage cost for NFTs. Instead of storing an NFT's\nmetadata in a typical Solana account, compressed NFTs store the metadata within\nthe ledger. This allows compressed NFTs to still inherit the security and speed\nof the Solana blockchain, while at the same time reducing the overall storage\ncosts.\nEven though the on-chain data storage mechanism is different than their\nuncompressed counterparts, compressed NFTs still follow the exact same\nMetadata\nschema/structure. Allowing you to define your Collection and NFT in an identical\nway.\nHowever, the process to mint and transfer compressed NFTs is different from\nuncompressed NFTs. Aside from using a different on-chain program, compressed\nNFTs are minting into a merkle tree and require verification of a \"proof\" to\ntransfer. More on this below.\nCompressed NFTs and indexers\u200bSince compressed NFTs store all of their metadata in the\nledger, instead of in traditional\naccounts like uncompressed NFTs, we will need to",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "help of indexing services to quickly fetch our compressed NFT's metadata.\nSupporting RPC providers are using the Digital Asset Standard Read API (or \"Read\nAPI\" for short) to add additional RPC methods that developers can call. These\nadditional, NFT oriented methods, are loaded with all the information about\nparticular NFTs. Including support for BOTH compressed NFTs AND\nuncompressed NFTs.\nMetadata is secured by the ledger and cached by indexersSince validators do not keep a very long history of the recent ledger data,\nthese indexers effectively \"cache\" the compressed NFT metadata passed through\nthe Solana ledger. Quickly serving it back on request to improve speed and user\nexperience of applications.\nHowever, since the metadata was already secured by the ledger when minting the\ncompressed NFT, anyone could re-index the metadata directly from the secure\nledger. Allowing for independent verification of the data, should the need or\ndesire arise.\nThese indexing services are already available from some of the common RPC\nproviders, with more rolling out support in the near future. To name a few of\nthe RPC providers that already support the Read API:HeliusTritonSimpleHashHow to mint compressed NFTs\u200bThe process to create or mint compressed NFTs on Solana is similar to creating a\n\"traditional NFT collection\", with a few differences. The mint process will\nhappen in 3 primary steps:create an NFT collection (or use an existing one)create a\nconcurrent merkle tree",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "(using the @solana/spl-account-compression SDK)mint compressed NFTs into your tree (to any owner's address you want)How to transfer a compressed NFT\u200bOnce your compressed NFT exists on the Solana blockchain, the process to\ntransfer ownership of a compressed NFT happens in a few broad steps:get the NFT \"asset\" information (from the indexer)get the NFT's \"proof\" (from the indexer)get the Merkle tree account (from the Solana blockchain)prepare the asset proof (by parsing and formatting it)build and send the transfer instructionThe first three steps primarily involve gathering specific pieces of information\n(the proof and the tree's canopy depth) for the NFT to be transferred. These\npieces of information are needed to correctly parse/format the proof to\nactually be sent within the transfer instruction itself.\nGetting started\u200bFor this guide, we are going to make a few assumptions about the compressed NFT\ncollection we are going to create:we are going to use TypeScript and NodeJS for this examplewe will use a single, new Metaplex collectionProject Setup\u200bBefore we start creating our compressed NFT collection, we need to install a few\npackages:@solana/web3.\njs - the base\nSolana JS SDK for interacting with the blockchain, including making our RPC\nconnection and sending transactions@solana/spl-token - used\nin creating our collection and mint on-chain@solana/spl-account-compression -\nused to create the on-chain tree to store our compressed NFTs@metaplex-foundation/mpl-bubblegum -",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "used to get the types and helper functions for minting and transferring\ncompressed NFTs on-chain@metaplex-foundation/mpl-token-metadata -\nused to get the types and helper functions for our NFT's metadataUsing your preferred package manager (e.\ng. npm, yarn, pnpm, etc), install these\npackages into your project:yarn add @solana/web3.\njs @solana/spl-token @solana/spl-account-compressionyarn add @metaplex-foundation/mpl-bubblegum @metaplex-foundation/mpl-token-metadataCreate a Collection\u200bNFTs are normally grouped together into a\nCollection\nusing the Metaplex standard. This is true for BOTH traditional NFTs AND\ncompressed NFTs. The NFT Collection will store all the broad metadata for our\nNFT grouping, such as the collection image and name that will appear in wallets\nand explorers.\nUnder the hood, an NFT collection acts similar to any other token on Solana.\nMore specifically, a Collection is effectively a uncompressed NFT. So we\nactually create them following the same process of creating an\nSPL token:create a new token \"mint\"create a associated token account (ata) for our token mintactually mint a single single tokenstore the collection's metadata in an Account on-chainSince NFT Collections having nothing special to do with\nState Compression or\ncompressed NFTs, we will not cover creating one in this\nguide.\nCollection addresses\u200bEven though this guide does not cover creating one, we will need the many of the",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "various addresses for your Collection, including:collectionAuthority - this may be your payer but it also might not becollectionMint - the collection's mint addresscollectionMetadata - the collection's metadata accounteditionAccount - for example, the masterEditionAccount created for your\ncollectionCreate a tree\u200bOne of the most important decisions to make when creating compressed NFTs is\nhow to setup your tree.\nEspecially since the values used to size your tree will determine the overall\ncost of creation, and CANNOT be changed after creation.\ncautionA tree is NOT the same thing as a collection. A single collection can use\nany number of trees. In fact, this is usually recommended for larger\ncollections due to smaller trees having greater composability.\nConversely, even though a tree could be used in multiple collections, it is\ngenerally considered an anti-pattern and is not recommended.\nUsing the helper functions provided by the\n@solana/spl-account-compression\nSDK, we can create our tree in the following steps:decide on our tree sizegenerate a new Keypair and allocated space for the tree on-chainactually create the tree (making it owned by the Bubblegum program)Size your tree\u200bYour tree size is set by 3 values, each serving a very specific purpose:maxDepth - used to determine how many NFTs we can have in the treemaxBufferSize - used to determine how many updates to your tree are",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "possible in the same blockcanopyDepth - used to store a portion of the proof on chain, and as such is\na large of cost and composability of your compressed NFT collectioninfoRead more about the details about\nState Compression, including\nhow to size a tree\nand potential composability concerns.\nLet's assume we are going to create a compressed NFT collection with 10k NFTs in\nit. And since our collection is relatively small, we only need a single smaller\ntree to store all the NFTs:// define the depth and buffer size of our tree to be createdconst maxDepthSizePair: ValidDepthSizePair = {  // max=16,384 nodes (for a `maxDepth` of 14)  maxDepth: 14,  maxBufferSize: 64,};// define the canopy depth of our tree to be createdconst canopyDepth = 10;Setting a maxDepth of 14 will allow our tree to hold up to 16,384\ncompressed NFTs, more than exceeding our 10k collection size.\nSince only specific\nValidDepthSizePair\npairs are allowed, simply set the maxBufferSize to the corresponding value\ntied to your desired maxDepth.\nNext, setting canopyDepth of 10 tells our tree to store 10 of our \"proof\nnode hashes\" on-chain. Thus requiring us to always include 4 proof node values\n(i.\ne. maxDepth - canopyDepth) in every compressed NFT transfer instruction.\nGenerate addresses for the tree\u200bWhen creating a new tree, we need to generate a new\nKeypair address for the tree to have:const treeKeypair = Keypair.\ngenerate();Since our tree will be used for compressed NFTs, we will also need to derive an",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "Account with authority that is owned by the Bubblegum program (i.\ne. PDA):// derive the tree's authority (PDA), owned by Bubblegumconst [treeAuthority, _bump] = PublicKey.\nfindProgramAddressSync(  [treeKeypair.\npublicKey.\ntoBuffer()],  BUBBLEGUM_PROGRAM_ID,);Build the tree creation instructions\u200bWith our tree size values defined, and our addresses generated, we need to build\ntwo related instructions:allocate enough space on-chain for our treeactually create the tree, owned by the Bubblegum programUsing the\ncreateAllocTreeIx\nhelper function, we allocate enough space on-chain for our tree.\n// allocate the tree's account on chain with the `space`const allocTreeIx = await createAllocTreeIx(  connection,  treeKeypair.\npublicKey,  payer.\npublicKey,  maxDepthSizePair,  canopyDepth,);Then using the\ncreateCreateTreeInstruction\nfrom the Bubblegum SDK, we actually create the tree on-chain. Making it owned by\nthe Bubblegum program.\n// create the instruction to actually create the treeconst createTreeIx = createCreateTreeInstruction(  {    payer: payer.\npublicKey,    treeCreator: payer.\npublicKey,    treeAuthority,    merkleTree: treeKeypair.\npublicKey,    compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,    // NOTE: this is used for some on chain logging    logWrapper: SPL_NOOP_PROGRAM_ID,  },  {    maxBufferSize: maxDepthSizePair.\nmaxBufferSize,    maxDepth: maxDepthSizePair.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "maxDepth,    public: false,  },  BUBBLEGUM_PROGRAM_ID,);Build and send the transaction\u200bWith our two instructions built, we can add them into a transaction and send\nthem to the blockchain, making sure both the payer and generated treeKeypair\nsign the transaction:// build the transactionconst tx = new Transaction().\nadd(allocTreeIx).\nadd(createTreeIx);tx.\nfeePayer = payer.\npublicKey;// send the transactionconst txSignature = await sendAndConfirmTransaction(  connection,  tx,  // ensuring the `treeKeypair` PDA and the `payer` are BOTH signers  [treeKeypair, payer],  {    commitment: \"confirmed\",    skipPreflight: true,  },);After a few short moments, and once the transaction is confirmed, we are ready\nto start minting compressed NFTs into our tree.\nMint compressed NFTs\u200bSince compressed NFTs follow the same Metaplex\nmetadata standards\nas traditional NFTs, we can define our actual NFTs data the same way.\nThe primary difference is that with compressed NFTs the metadata is actually\nstored in the ledger (unlike traditional NFTs that store them in accounts). The\nmetadata gets \"hashed\" and stored in our tree, and by association, secured by\nthe Solana ledger.\nAllowing us to cryptographically verify that our original metadata has not\nchanged (unless we want it to).\ninfoLearn more about how State Compression uses\nconcurrent merkle trees\nto cryptographically secure off-chain data using the Solana ledger.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "Define our NFT's metadata\u200bWe can define the specific metadata for the single NFT we are about to mint:const compressedNFTMetadata: MetadataArgs = {  name: \"NFT Name\",  symbol: \"ANY\",  // specific json metadata for each NFT  uri: \"https://supersweetcollection.\nnotarealurl/token.\njson\",  creators: null,  editionNonce: 0,  uses: null,  collection: null,  primarySaleHappened: false,  sellerFeeBasisPoints: 0,  isMutable: false,  // these values are taken from the Bubblegum package  tokenProgramVersion: TokenProgramVersion.\nOriginal,  tokenStandard: TokenStandard.\nNonFungible,};In this demo, the key pieces of our NFT's metadata to note are:name - this is the actual name of our NFT that will be displayed in wallets\nand on explorers.\nuri - this is the address for your NFTs metadata JSON file.\ncreators - for this example, we are not storing a list of creators. If you\nwant your NFTs to have royalties, you will need to store actual data here. You\ncan checkout the Metaplex docs for more info on it.\nDerive the Bubblegum signer\u200bWhen minting new compressed NFTs, the Bubblegum program needs a PDA to perform a\ncross-program invocation\n(cpi) to the SPL compression program.\ncautionThis bubblegumSigner PDA is derived using a hard coded seed string of\ncollection_cpi and owned by the Bubblegum program. If this hard coded value is\nnot provided correctly, your compressed NFT minting will fail.\nBelow, we derive this PDA using the required hard coded seed string of",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "collection_cpi:// derive a PDA (owned by Bubblegum) to act as the signer of the compressed mintingconst [bubblegumSigner, _bump2] = PublicKey.\nfindProgramAddressSync(  // `collection_cpi` is a custom prefix required by the Bubblegum program  [Buffer.\nfrom(\"collection_cpi\", \"utf8\")],  BUBBLEGUM_PROGRAM_ID,);Create the mint instruction\u200bNow we should have all the information we need to actually mint our compressed\nNFT.\nUsing the createMintToCollectionV1Instruction helper function provided in the\nBubblegum SDK, we can craft the instruction to actually mint our compressed NFT\ndirectly into our collection.\nIf you have minted traditional NFTs on Solana, this will look fairly similar. We\nare creating a new instruction, giving several of the account addresses you\nmight expect (e.\ng. the payer, tokenMetadataProgram, and various collection\naddresses), and then some tree specific addresses.\nThe addresses to pay special attention to are:leafOwner - this will be the owner of the compressed NFT. You can either\nmint it your self (i.\ne. the payer), or airdrop to any other Solana addressleafDelegate - this is the delegated authority of this specific NFT we are\nabout to mint. If you do not want to have a delegated authority for the NFT we\nare about to mint, then this value should be set to the same address of\nleafOwner.\nconst compressedMintIx = createMintToCollectionV1Instruction(  {    payer: payer.\npublicKey,    merkleTree: treeAddress,    treeAuthority,    treeDelegate: payer.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "publicKey,    // set the receiver of the NFT    leafOwner: receiverAddress || payer.\npublicKey,    // set a delegated authority over this NFT    leafDelegate: payer.\npublicKey,    // collection details    collectionAuthority: payer.\npublicKey,    collectionAuthorityRecordPda: BUBBLEGUM_PROGRAM_ID,    collectionMint: collectionMint,    collectionMetadata: collectionMetadata,    editionAccount: collectionMasterEditionAccount,    // other accounts    bubblegumSigner: bubblegumSigner,    compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,    logWrapper: SPL_NOOP_PROGRAM_ID,    tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,  },  {    metadataArgs: Object.\nassign(compressedNFTMetadata, {      collection: { key: collectionMint, verified: false },    }),  },);Some of the other tree specific addresses are:merkleTree - the address of our tree we createdtreeAuthority - the authority of the treetreeDelegate - the delegated authority of the entire treeThen we also have all of our NFT collection's addresses, including the mint\naddress, metadata account, and edition account. These addresses are also\nstandard to pass in when minting uncompressed NFTs.\nSign and send the transaction\u200bOnce our compressed mint instruction has been created, we can add it to a\ntransaction and send it to the Solana network:const tx = new Transaction().\nadd(compressedMintIx);tx.\nfeePayer = payer.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "publicKey;// send the transaction to the clusterconst txSignature = await sendAndConfirmTransaction(connection, tx, [payer], {  commitment: \"confirmed\",  skipPreflight: true,});Reading compressed NFTs metadata\u200bWith the help of a supporting RPC provider, developers can use the Digital Asset\nStandard Read API (or \"Read API\" for short) to fetch the metadata of NFTs.\ninfoThe Read API supports both compressed NFTs and traditional/uncompressed NFTs.\nYou can use the same RPC endpoints to retrieve all the assorted information for\nboth types of NFTs, including auto-fetching the NFTs' JSON URI.\nUsing the Read API\u200bWhen working with the Read API and a supporting RPC provider, developers can\nmake POST requests to the RPC endpoint using your preferred method of making\nsuch requests (e.\ng. curl, JavaScript fetch(), etc).\nAsset IDWithin the Read API, digital assets (i.\ne. NFTs) are indexed by their id. This\nasset id value differs slightly between traditional NFTs and compressed NFTs:for traditional/uncompressed NFTs: this is the token's address for the actual\nAccount on-chain that stores the metadata for the asset.\nfor compressed NFTs: this is the id of the compressed NFT within the tree\nand is NOT an actual on-chain Account address. While a compressed NFT's\nassetId resembles a traditional Solana Account address, it is not.\nCommon Read API Methods\u200bWhile the Read API supports more than these listed below, the most commonly used",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "methods are:getAsset - get a specific NFT asset by its idgetAssetProof - returns the merkle proof that is required to transfer a\ncompressed NFT, by its asset idgetAssetsByOwner - get the assets owned by a specific addressgetAssetsByGroup - get the assets by a specific grouping (i.\ne. a collection)Read API Methods, Schema, and SpecificationExplore all the additional RPC methods added by Digital Asset Standard Read API\non Metaplex's RPC Playground. Here you\nwill also find the expected inputs and response schema for each supported RPC\nmethod.\nExample Read API Request\u200bFor demonstration, below is an example request for the getAsset method using\nthe\nJavaScript Fetch API,\nwhich is built into modern JavaScript runtimes:// make a POST request to the RPC using the JavaScript `fetch` apiconst response = await fetch(rpcEndpointUrl, {  method: \"POST\",  headers: {    \"Content-Type\": \"application/json\",  },  body: JSON.\nstringify({    jsonrpc: \"2.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "0\",    id: \"rpd-op-123\",    method: \"getAsset\",    params: {      id: \"5q7qQ4FWYyj4vnFrivRBe6beo6p88X8HTkkyVPjPkQmF\",    },  }),});Example Read API Response\u200bWith a successful response from the RPC, you should seem similar data to this:{  interface: 'V1_NFT',  id: '5q7qQ4FWYyj4vnFrivRBe6beo6p88X8HTkkyVPjPkQmF',  content: [Object],  authorities: [Array],  compression: [Object],  grouping: [],  royalty: [Object],  creators: [],  ownership: [Object],  supply: [Object],  mutable: false}The response fields to pay special attention to are:id - this is your asset's idgrouping - can tell you the collection address that the NFT belongs to. The\ncollection address will be the group_value.\nmetadata - contains the actual metadata for the NFT, including the auto\nfetched JSON uri set when the NFT was mintedownership - gives you the NFT owner's address (and also if the NFT has\ndelegated authority to another address)compression - tells you if this NFT is actually using compression or not.\nFor compressed NFTs, this will also give you the tree address that is storing\nthe compressed NFT on chain.\ncautionSome of the returned values may be empty if the NFT is not a compressed NFT,\nsuch as many of the compression fields. This is expected.\nTransfer compressed NFTs\u200bTransferring compressed NFTs is different from transferring uncompressed NFTs.\nAside from using a different on-chain program, compressed NFTs require the use\nof a asset's \"merkle proof\" (or proof for short) to actually change ownership.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "What is a merkle proof?\nAn asset's \"merkle proof\" is a listing of all the \"adjacent hashes\" within the\ntree that are required to validate a specific leaf within said tree.\nThese proof hashes themselves, and the specific asset's leaf data, are hashed\ntogether in a deterministic way to compute the \"root hash\". Therefore, allowing\nfor cryptographic validation of an asset within the merkle tree.\nNOTE: While each of these hash values resemble a Solana Account's\naddress/public key, they are not\naddresses.\nTransferring ownership of a compressed NFT happens in 5 broad steps:get the NFT's \"asset\" data (from the indexer)get the NFT's proof (from the indexer)get the Merkle tree account (directly from the Solana blockchain)prepare the asset proofbuild and send the transfer instructionThe first three steps primarily involve gathering specific pieces of information\n(the proof and the tree's canopy depth) for the NFT to be transferred. These\npieces of information are needed to correctly parse/format the proof to\nactually be sent within the transfer instruction itself.\nGet the asset\u200bTo perform the transfer of our compressed NFT, we will need to retrieve a few\npieces of information about the NFT.\nFor starters, we will need to get some the asset's information in order to allow\nthe on-chain compression program to correctly perform validation and security\nchecks.\nWe can use the getAsset RPC method to retrieve two important pieces of",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "information for the compressed NFT: the data_hash and creator_hash.\nExample response from the getAsset method\u200bBelow is an example response from the getAsset method:compression: {  eligible: false,  compressed: true,  data_hash: 'D57LAefACeaJesajt6VPAxY4QFXhHjPyZbjq9efrt3jP',  creator_hash: '6Q7xtKPmmLihpHGVBA6u1ENE351YKoyqd3ssHACfmXbn',  asset_hash: 'F3oDH1mJ47Z7tNBHvrpN5UFf4VAeQSwTtxZeJmn7q3Fh',  tree: 'BBUkS4LZQ7mU8iZXYLVGNUjSxCYnB3x44UuPVHVXS9Fo',  seq: 3,  leaf_id: 0}Get the asset proof\u200bThe next step in preparing your compressed NFT transfer instruction, is to get a\nvalid asset proof to perform the transfer. This proof is required by the\non-chain compression program to validate on-chain information.\nWe can use the getAssetProof RPC method to retrieve two important pieces of\ninformation:proof - the \"full proof\" that is required to perform the transfer (more on\nthis below)tree_id - the on-chain address of the compressed NFTs treeFull proof is returnedThe getAssetProof RPC method returns the complete listing of \"proof hashes\"\nthat are used to perform the compressed NFT transfer. Since this \"full proof\" is\nreturned from the RPC, we will need to remove the portion of the \"full proof\"\nthat is stored on-chain via the tree's canopy.\nExample response from the getAssetProof method\u200bBelow is an example response from the getAssetProof method:{  root: '7dy5bzgaRcUnNH2KMExwNXXNaCJnf7wQqxc2VrGXy9qr',  proof: [    'HdvzZ4hrPEdEarJfEzAavNJEZcCS1YU1fg2uBvQGwAAb',    .\n.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": ".    '3e2oBSLfSDVdUdS7jRGFKa8nreJUA9sFPEELrHaQyd4J'  ],  node_index: 131072,  leaf: 'F3oDH1mJ47Z7tNBHvrpN5UFf4VAeQSwTtxZeJmn7q3Fh',  tree_id: 'BBUkS4LZQ7mU8iZXYLVGNUjSxCYnB3x44UuPVHVXS9Fo'}Get the Merkle tree account\u200bSince the getAssetProof will always return the \"full proof\", we will have to\nreduce it down in order to remove the proof hashes that are stored on-chain in\nthe tree's canopy. But in order to remove the correct number of proof addresses,\nwe need to know the tree's canopyDepth.\nOnce we have our compressed NFT's tree address (the tree_id value from\ngetAssetProof), we can use the\nConcurrentMerkleTreeAccount\nclass, from the @solana/spl-account-compression SDK:// retrieve the merkle tree's account from the blockchainconst treeAccount = await ConcurrentMerkleTreeAccount.\nfromAccountAddress(  connection,  treeAddress,);// extract the needed values for our transfer instructionconst treeAuthority = treeAccount.\ngetAuthority();const canopyDepth = treeAccount.\ngetCanopyDepth();For the transfer instruction, we will also need the current treeAuthority\naddress which we can also get via the treeAccount.\nPrepare the asset proof\u200bWith our \"full proof\" and canopyDepth values on hand, we can correctly format\nthe proof to be submitted within the transfer instruction itself.\nSince we will use the createTransferInstruction helper function from the\nBubblegum SDK to actually build our transfer instruction, we need to:remove the proof values that are already stored on-chain in the",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "tree's canopy, andconvert the remaining proof values into the valid AccountMeta structure that\nthe instruction builder function accepts// parse the list of proof addresses into a valid AccountMeta[]const proof: AccountMeta[] = assetProof.\nproof  .\nslice(0, assetProof.\nproof.\nlength - (!\n!\ncanopyDepth ? canopyDepth : 0))  .\nmap((node: string) => ({    pubkey: new PublicKey(node),    isSigner: false,    isWritable: false,  }));In the TypeScript code example above, we are first taking a slice of our \"full\nproof\", starting at the beginning of the array, and ensuring we only have\nproof.\nlength - canopyDepth number of proof values. This will remove the\nportion of the proof that is already stored on-chain in the tree's canopy.\nThen we are structuring each of the remaining proof values as a valid\nAccountMeta, since the proof is submitted on-chain in the form of \"extra\naccounts\" within the transfer instruction.\nBuild the transfer instruction\u200bFinally, with all the required pieces of data about our tree and compressed\nNFTs, and a correctly formatted proof, we are ready to actually create the\ntransfer instruction.\nBuild your transfer instruction using the\ncreateTransferInstruction",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "helper function from the Bubblegum SDK:// create the NFT transfer instruction (via the Bubblegum package)const transferIx = createTransferInstruction(  {    merkleTree: treeAddress,    treeAuthority,    leafOwner,    leafDelegate,    newLeafOwner,    logWrapper: SPL_NOOP_PROGRAM_ID,    compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,    anchorRemainingAccounts: proof,  },  {    root: [.\n.\n.\nnew PublicKey(assetProof.\nroot.\ntrim()).\ntoBytes()],    dataHash: [.\n.\n.\nnew PublicKey(asset.\ncompression.\ndata_hash.\ntrim()).\ntoBytes()],    creatorHash: [      .\n.\n.\nnew PublicKey(asset.\ncompression.\ncreator_hash.\ntrim()).\ntoBytes(),    ],    nonce: asset.\ncompression.\nleaf_id,    index: asset.\ncompression.\nleaf_id,  },  BUBBLEGUM_PROGRAM_ID,);Aside from passing in our assorted Account addresses and the asset's proof, we\nare converting the string values of our data_hash, creator_hash, root hash\ninto an array of bytes that is accepted by the createTransferInstruction\nhelper function.\nSince each of these hash values resemble and are formatted similar to\nPublicKeys, we can use the\nPublicKey\nclass in web3.\njs to convert them into a accepted byte array format.\nSend the transaction\u200bWith our transfer instructions built, we can add it into a transaction and send\nit to the blockchain similar to before. Making sure either the current\nleafOwner or the leafDelegate signs the transaction.\nnoteAfter each successful transfer of a compressed NFT, the leafDelegate should",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/guides/compressed-nfts",
        "title": "compressed-nfts",
        "content": "reset to an empty value. Meaning the specific asset will not have delegated\nauthority to an address other than its owner.\nAnd once confirmed by the cluster, we will have successfully transferred a\ncompressed NFT.\nExample code repository\u200bYou can find an example code repository for this developer guide on the Solana\nDevelopers GitHub: https://github.\ncom/solana-developers/compressed-nfts",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/intro/programs",
        "title": "programs",
        "content": "What are Solana Programs?\nSolana Programs, often referred to as \"smart contracts\" on other blockchains, are the executable code that interprets the instructions sent inside of each transaction on the blockchain. They can be deployed directly into the core of the network as Native Programs, or published by anyone as On Chain Programs. Programs are the core building blocks of the network and handle everything from sending tokens between wallets, to accepting votes of a DAOs, to tracking ownership of NFTs.\nBoth types of programs run on top of the Sealevel runtime, which is Solana's parallel processing model that helps to enable the high transactions speeds of the blockchain.\nKey points\u200bPrograms are essentially special type of Accounts that is marked as \"executable\"Programs can own other AccountsPrograms can only change the data or debit accounts they ownAny program can read or credit another accountPrograms are considered stateless since the primary data stored in a program account is the compiled BPF codePrograms can be upgraded by their owner (see more on that below)Types of programs\u200bThe Solana blockchain has two types of programs:Native programsOn chain programsOn chain programs\u200bThese user written programs, often referred to as \"smart contracts\" on other blockchains, are deployed directly to the blockchain for anyone to interact with and execute. Hence the name \"on chain\"!",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/intro/programs",
        "title": "programs",
        "content": "In effect, \"on chain programs\" are any program that is not baked directly into the Solana cluster's core code (like the native programs discussed below).\nAnd even though Solana Labs maintains a small subset of these on chain programs (collectively known as the Solana Program Library), anyone can create or publish one. On chain programs can also be updated directly on the blockchain by the respective program's Account owner.\nNative programs\u200bNative programs are programs that are built directly into the core of the Solana blockchain.\nSimilar to other \"on chain\" programs in Solana, native programs can be called by any other program/user. However, they can only be upgraded as part of the core blockchain and cluster updates. These native program upgrades are controlled via the releases to the different clusters.\nExamples of native programs include:\u200bSystem Program: Create new accounts, transfer tokens, and moreBPF Loader Program: Deploys, upgrades, and executes programs on chainVote program: Create and manage accounts that track validator voting state and rewards.\nExecutable\u200bWhen a Solana program is deployed onto the network, it is marked as \"executable\" by the BPF Loader Program. This allows the Solana runtime to efficiently and properly execute the compiled program code.\nUpgradable\u200bUnlike other blockchains, Solana programs can be upgraded after they are deployed to the network.\nNative programs can only be upgraded as part of cluster updates when new software releases are made.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/intro/programs",
        "title": "programs",
        "content": "On chain programs can be upgraded by the account that is marked as the \"Upgrade Authority\", which is usually the Solana account/address that deployed the program to begin with.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/intro/rent",
        "title": "rent",
        "content": "What is rent?\nThe fee every Solana Account to store data on the blockchain is called \"rent\". This time and space based fee is required to keep an account, and its therefore its data, alive on the blockchain since clusters must actively maintain this data.\nAll Solana Accounts (and therefore Programs) are required to maintain a high enough LAMPORT balance to become rent exempt and remain on the Solana blockchain.\nWhen an Account no longer has enough LAMPORTS to pay its rent, it will be removed from the network in a process known as Garbage Collection.\nNote: Rent is different from transactions fees. Rent is paid (or held in an Account) to keep data stored on the Solana blockchain. Where as transaction fees are paid to process instructions on the network.\nRent rate\u200bThe Solana rent rate is set on a network wide basis, primarily based on the set LAMPORTS per byte per year.\nCurrently, the rent rate is a static amount and stored in the the Rent sysvar.\nRent exempt\u200bAccounts that maintain a minimum LAMPORT balance greater than 2 years worth of rent payments are considered \"rent exempt\" and will not incur a rent collection.\nAt the time of writing this, new Accounts and Programs are required to be initialized with enough LAMPORTS to become rent-exempt. The RPC endpoints have the ability to calculate this estimated rent exempt balance and is recommended to be used.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/intro/rent",
        "title": "rent",
        "content": "Every time an account's balance is reduced, a check is performed to see if the account is still rent exempt. Transactions that would cause an account's balance to drop below the rent exempt threshold will fail.\nGarbage collection\u200bAccounts that do not maintain their rent exempt status, or have a balance high enough to pay rent, are removed from the network in a process known as garbage collection. This process is done to help reduce the network wide storage of no longer used/maintained data.\nYou can learn more about garbage collection here in this implemented proposal.\nLearn more about Rent\u200bYou can learn more about Solana Rent with the following articles and documentation:Implemented Proposals - RentImplemented Proposals - Account Storage",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/lookup-tables",
        "title": "lookup-tables",
        "content": "Address Lookup TablesAddress Lookup Tables, commonly referred to as \"lookup tables\" or \"ALTs\" for short, allow developers to create a collection of related addresses to efficiently load more addresses in a single transaction.\nSince each transaction on the Solana blockchain requires a listing of every address that is interacted with as part of the transaction, this listing would be effectively be capped at 32 address per transaction. With the help of Address Lookup Tables, a transaction would be now be able to raise that limit to 256 addresses per transaction.\nCompressing on chain addresses\u200bAfter all the desired address have been stored on chain in an Address Lookup Table, each address can be referenced inside a transaction by its 1-byte index within the table (instead of their full 32-byte address). This lookup method effectively \"compresses\" a 32-byte address into a 1-byte index value.\nThis \"compression\" enables storing up to 256 address in a single lookup table for use inside any given transaction.\nVersioned Transactions\u200bTo utilize an Address Lookup Table inside a transaction, developers must use v0 transactions that were introduced with the new Versioned Transaction format.\nHow to create an address lookup table\u200bCreating a new lookup table with the @solana/web3.\njs library is similar to the older legacy transactions, but with some differences.\nUsing the @solana/web3.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/lookup-tables",
        "title": "lookup-tables",
        "content": "js library, you can use the createLookupTable function to construct the instruction needed to create a new lookup table, as well as determine its address:const web3 = require(\"@solana/web3.\njs\");// connect to a cluster and get the current `slot`const connection = new web3.\nConnection(web3.\nclusterApiUrl(\"devnet\"));const slot = await connection.\ngetSlot();// Assumption:// `payer` is a valid `Keypair` with enough SOL to pay for the executionconst [lookupTableInst, lookupTableAddress] =  web3.\nAddressLookupTableProgram.\ncreateLookupTable({    authority: payer.\npublicKey,    payer: payer.\npublicKey,    recentSlot: slot,  });console.\nlog(\"lookup table address:\", lookupTableAddress.\ntoBase58());// To create the Address Lookup Table on chain:// send the `lookupTableInst` instruction in a transactionNOTE:\nAddress lookup tables can be created with either a v0 transaction or a legacy transaction. But the Solana runtime can only retrieve and handle the additional addresses within a lookup table while using v0 Versioned Transactions.\nAdd addresses to a lookup table\u200bAdding addresses to a lookup table is known as \"extending\". Using the the @solana/web3.\njs library, you can create a new extend instruction using the extendLookupTable method:// add addresses to the `lookupTableAddress` table via an `extend` instructionconst extendInstruction = web3.\nAddressLookupTableProgram.\nextendLookupTable({  payer: payer.\npublicKey,  authority: payer.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/lookup-tables",
        "title": "lookup-tables",
        "content": "publicKey,  lookupTable: lookupTableAddress,  addresses: [    payer.\npublicKey,    web3.\nSystemProgram.\nprogramId,    // list more `publicKey` addresses here  ],});// Send this `extendInstruction` in a transaction to the cluster// to insert the listing of `addresses` into your lookup table with address `lookupTableAddress`NOTE:\nDue to the same memory limits of legacy transactions, any transaction used to extend an Address Lookup Table is also limited in how many addresses can be added at a time. Because of this, you will need to use multiple transactions to extend any table with more addresses (~20) that can fit withing a single transaction's memory limits.\nOnce these address have been inserted into the table, and stored on chain, you will be able to utilize the Address Lookup Table in future transactions. Enabling up to 256 address in those future transactions.\nFetch an Address Lookup Table\u200bSimilar to requesting another account (or PDA) from the cluster, you can fetch a complete Address Lookup Table with the getAddressLookupTable method:// define the `PublicKey` of the lookup table to fetchconst lookupTableAddress = new web3.\nPublicKey(\"\");// get the table from the clusterconst lookupTableAccount = await connection  .\ngetAddressLookupTable(lookupTableAddress)  .\nthen((res) => res.\nvalue);// `lookupTableAccount` will now be a `AddressLookupTableAccount` objectconsole.\nlog(\"Table address from cluster:\", lookupTableAccount.\nkey.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/lookup-tables",
        "title": "lookup-tables",
        "content": "toBase58());Our lookupTableAccount variable will now be a AddressLookupTableAccount object which we can parse to read the listing of all the addresses stored on chain in the lookup table:// loop through and parse all the address stored in the tablefor (let i = 0; i < lookupTableAccount.\nstate.\naddresses.\nlength; i++) {  const address = lookupTableAccount.\nstate.\naddresses[i];  console.\nlog(i, address.\ntoBase58());}How to use an address lookup table in a transaction\u200bAfter you have created your lookup table, and stored your needed address on chain (via extending the lookup table), you can create a v0 transaction to utilize the on chain lookup capabilities.\nJust like older legacy transactions, you can create all the instructions your transaction will execute on chain. You can then provide an array of these instructions to the Message used in the `v0 transaction.\nNOTE:\nThe instructions used inside a v0 transaction can be constructed using the same methods and functions used to create the instructions in the past. There is no required change to the instructions used involving an Address Lookup Table.\n// Assumptions:// - `arrayOfInstructions` has been created as an `array` of `TransactionInstruction`// - we are are using the `lookupTableAccount` obtained above// construct a v0 compatible transaction `Message`const messageV0 = new web3.\nTransactionMessage({  payerKey: payer.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/lookup-tables",
        "title": "lookup-tables",
        "content": "publicKey,  recentBlockhash: blockhash,  instructions: arrayOfInstructions, // note this is an array of instructions}).\ncompileToV0Message([lookupTableAccount]);// create a v0 transaction from the v0 messageconst transactionV0 = new web3.\nVersionedTransaction(messageV0);// sign the v0 transaction using the file system wallet we created named `payer`transactionV0.\nsign([payer]);// send and confirm the transaction// (NOTE: There is NOT an array of Signers here; see the note below.\n.\n.\n)const txid = await web3.\nsendAndConfirmTransaction(connection, transactionV0);console.\nlog(  `Transaction: https://explorer.\nsolana.\ncom/tx/${txidV0}?\ncluster=devnet`,);NOTE:\nWhen sending a VersionedTransaction to the cluster, it must be signed BEFORE calling the\nsendAndConfirmTransaction method. If you pass an array of Signer\n(like with legacy transactions) the method will trigger an error!\nMore Resources\u200bRead the proposal for Address Lookup Tables and Versioned transactionsExample Rust program using Address Lookup Tables",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/debugging",
        "title": "debugging",
        "content": "Debugging ProgramsSolana programs run on-chain, so debugging them in the wild can be challenging.\nTo make debugging programs easier, developers can write unit tests that directly\ntest their program's execution via the Solana runtime, or run a local cluster\nthat will allow RPC clients to interact with their program.\nRunning unit tests\u200bTesting with RustTesting with CLogging\u200bDuring program execution both the runtime and the program log status and error\nmessages.\nFor information about how to log from a program see the language specific\ndocumentation:Logging from a Rust programLogging from a C programWhen running a local cluster the logs are written to stdout as long as they are\nenabled via the RUST_LOG log mask. From the perspective of program\ndevelopment it is helpful to focus on just the runtime and program logs and not\nthe rest of the cluster logs. To focus in on program specific information the\nfollowing log mask is recommended:export RUST_LOG=solana_runtime::system_instruction_processor=trace,solana_runtime::message_processor=info,solana_bpf_loader=debug,solana_rbpf=debugLog messages coming directly from the program (not the runtime) will be\ndisplayed in the form:Program log: <user defined message>Error Handling\u200bThe amount of information that can be communicated via a transaction error is\nlimited but there are many points of possible failures. The following are\npossible failure points and information about what errors to expect and where to",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/debugging",
        "title": "debugging",
        "content": "get more information:The BPF loader may fail to parse the program, this should not happen since the\nloader has already finalized the program's account data.\nInstructionError::InvalidAccountData will be returned as part of the\ntransaction error.\nThe BPF loader may fail to setup the program's execution environmentInstructionError::Custom(0x0b9f_0001) will be returned as part of the\ntransaction error. \"0x0b9f_0001\" is the hexadecimal representation of\nVirtualMachineCreationFailed.\nThe BPF loader may have detected a fatal error during program executions\n(things like panics, memory violations, system call errors, etc.\n.\n.\n)InstructionError::Custom(0x0b9f_0002) will be returned as part of the\ntransaction error. \"0x0b9f_0002\" is the hexadecimal representation of\nVirtualMachineFailedToRunProgram.\nThe program itself may return an errorInstructionError::Custom(<user defined value>) will be returned. The\n\"user defined value\" must not conflict with any of the builtin runtime\nprogram\nerrors.\nPrograms typically use enumeration types to define error codes starting at\nzero so they won't conflict.\nIn the case of VirtualMachineFailedToRunProgram errors, more information about\nthe specifics of what failed are written to the program's execution\nlogs.\nFor example, an access violation involving the stack will look something like",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/debugging",
        "title": "debugging",
        "content": "this:BPF program 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM failed: out of bounds memory store (insn #615), addr 0x200001e38/8Monitoring Compute Budget Consumption\u200bThe program can log the remaining number of compute units it will be allowed\nbefore program execution is halted. Programs can use these logs to wrap\noperations they wish to profile.\nLog the remaining compute units from a Rust\nprogramLog the remaining compute units from a C\nprogramSee compute budget\nfor more information.\nELF Dump\u200bThe BPF shared object internals can be dumped to a text file to gain more\ninsight into a program's composition and what it may be doing at runtime.\nCreate a dump file of a Rust programCreate a dump file of a C programInstruction Tracing\u200bDuring execution the runtime BPF interpreter can be configured to log a trace\nmessage for each BPF instruction executed. This can be very helpful for things\nlike pin-pointing the runtime context leading up to a memory access violation.\nThe trace logs together with the ELF dump can provide a lot of\ninsight (though the traces produce a lot of information).\nTo turn on BPF interpreter trace messages in a local cluster configure the\nsolana_rbpf level in RUST_LOG to trace. For example:export RUST_LOG=solana_rbpf=trace",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/deploying",
        "title": "deploying",
        "content": "Deploying ProgramsAs shown in the diagram above, a program author creates a program, compiles it\nto an ELF shared object containing BPF bytecode, and uploads it to the Solana\ncluster with a special deploy transaction. The cluster makes it available to\nclients via a program ID. The program ID is an address specified when\ndeploying and is used to reference the program in subsequent transactions.\nUpon a successful deployment the account that holds the program is marked\nexecutable. If the program is marked \"final\", its account data become permanently\nimmutable. If any changes are required to the finalized program (features, patches,\netc.\n.\n.\n) the new program must be deployed to a new program ID.\nIf a program is upgradeable, the account that holds the program is marked\nexecutable, but it is possible to redeploy a new shared object to the same\nprogram ID, provided that the program's upgrade authority signs the transaction.\nThe Solana command line interface supports deploying programs, for more\ninformation see the deploy command line usage\ndocumentation.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/developing-c",
        "title": "developing-c",
        "content": "Developing with CSolana supports writing on-chain programs using the C and C++ programming\nlanguages.\nProject Layout\u200bC projects are laid out as follows:/src/<program name>/makefileThe makefile should contain the following:OUT_DIR := <path to place to resulting shared object>include ~/.\nlocal/share/solana/install/active_release/bin/sdk/bpf/c/bpf.\nmkThe bpf-sdk may not be in the exact place specified above but if you setup your\nenvironment per How to Build then it should be.\nTake a look at\nhelloworld\nfor an example of a C program.\nHow to Build\u200bFirst setup the environment:Install the latest Rust stable from https://rustup.\nrsInstall the latest Solana command-line toolsThen build using make:make -C <program directory>How to Test\u200bSolana uses the Criterion test framework\nand tests are executed each time the program is built How to\nBuild.\nTo add tests, create a new file next to your source file named test_<program name>.\nc and populate it with criterion test cases. For an example see the\nhelloworld C\ntests\nor the Criterion docs for\ninformation on how to write a test case.\nProgram Entrypoint\u200bPrograms export a known entrypoint symbol which the Solana runtime looks up and\ncalls when invoking a program. Solana supports multiple versions of the BPF\nloader and the entrypoints may vary between them.\nPrograms must be written for and deployed to the same loader. For more details\nsee the overview.\nCurrently there are two supported loaders BPF\nLoader\nand BPF loader\ndeprecated.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/developing-c",
        "title": "developing-c",
        "content": "They both have the same raw entrypoint definition, the following is the raw\nsymbol that the runtime looks up and calls:extern uint64_t entrypoint(const uint8_t *input)This entrypoint takes a generic byte array which contains the serialized program\nparameters (program id, accounts, instruction data, etc.\n.\n.\n). To deserialize the\nparameters each loader contains its own helper function.\nRefer to helloworld's use of the\nentrypoint\nas an example of how things fit together.\nSerialization\u200bRefer to helloworld's use of the deserialization\nfunction.\nEach loader provides a helper function that deserializes the program's input\nparameters into C types:BPF Loader\ndeserializationBPF Loader deprecated\ndeserializationSome programs may want to perform deserialization themselves, and they can by\nproviding their own implementation of the raw entrypoint.\nTake note that the provided deserialization functions retain references back to\nthe serialized byte array for variables that the program is allowed to modify\n(lamports, account data). The reason for this is that upon return the loader\nwill read those modifications so they may be committed. If a program implements\ntheir own deserialization function they need to ensure that any modifications\nthe program wishes to commit must be written back into the input byte array.\nDetails on how the loader serializes the program inputs can be found in the\nInput Parameter Serialization docs.\nData Types\u200bThe loader's deserialization helper function populates the",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/developing-c",
        "title": "developing-c",
        "content": "SolParameters\nstructure:/** * Structure that the program's entrypoint input data is deserialized into. */typedef struct {  SolAccountInfo* ka; /** Pointer to an array of SolAccountInfo, must already                          point to an array of SolAccountInfos */  uint64_t ka_num; /** Number of SolAccountInfo entries in `ka` */  const uint8_t *data; /** pointer to the instruction data */  uint64_t data_len; /** Length in bytes of the instruction data */  const SolPubkey *program_id; /** program_id of the currently executing program */} SolParameters;'ka' is an ordered array of the accounts referenced by the instruction and\nrepresented as a\nSolAccountInfo\nstructures. An account's place in the array signifies its meaning, for example,\nwhen transferring lamports an instruction may define the first account as the\nsource and the second as the destination.\nThe members of the SolAccountInfo structure are read-only except for\nlamports and data. Both may be modified by the program in accordance with\nthe runtime enforcement\npolicy. When an instruction\nreference the same account multiple times there may be duplicate\nSolAccountInfo entries in the array but they both point back to the original\ninput byte array. A program should handle these cases delicately to avoid\noverlapping read/writes to the same buffer. If a program implements their own\ndeserialization function care should be taken to handle duplicate accounts\nappropriately.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/developing-c",
        "title": "developing-c",
        "content": "data is the general purpose byte array from the instruction's instruction\ndata being\nprocessed.\nprogram_id is the public key of the currently executing program.\nHeap\u200bC programs can allocate memory via the system call\ncalloc\nor implement their own heap on top of the 32KB heap region starting at virtual\naddress x300000000. The heap region is also used by calloc so if a program\nimplements their own heap it should not also call calloc.\nLogging\u200bThe runtime provides two system calls that take data and log it to the program\nlogs.\nsol_log(const char*)sol_log_64(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t)The debugging section has more information about working\nwith program logs.\nCompute Budget\u200bUse the system call\nsol_log_compute_units()\nto log a message containing the remaining number of compute units the program\nmay consume before execution is haltedSee compute budget\nfor more information.\nELF Dump\u200bThe BPF shared object internals can be dumped to a text file to gain more\ninsight into a program's composition and what it may be doing at runtime. The\ndump will contain both the ELF information as well as a list of all the symbols\nand the instructions that implement them. Some of the BPF loader's error log\nmessages will reference specific instruction numbers where the error occurred.\nThese references can be looked up in the ELF dump to identify the offending\ninstruction and its context.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/developing-c",
        "title": "developing-c",
        "content": "To create a dump file:$ cd <program directory>$ make dump_<program name>Examples\u200bThe Solana Program Library github repo contains a collection of C examples",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/developing-rust",
        "title": "developing-rust",
        "content": "Developing with RustSolana supports writing on-chain programs using the\nRust programming language.\nProject Layout\u200bSolana Rust programs follow the typical Rust project\nlayout:/inc//src//Cargo.\ntomlSolana Rust programs may depend directly on each other in order to gain access\nto instruction helpers when making cross-program invocations.\nWhen doing so it's important to not pull in the dependent program's entrypoint\nsymbols because they may conflict with the program's own. To avoid this,\nprograms should define an no-entrypoint feature in Cargo.\ntoml and use\nto exclude the entrypoint.\nDefine the\nfeatureExclude the\nentrypointThen when other programs include this program as a dependency, they should do so\nusing the no-entrypoint feature.\nInclude without\nentrypointProject Dependencies\u200bAt a minimum, Solana Rust programs must pull in the\nsolana-program crate.\nSolana BPF programs have some restrictions that may prevent the\ninclusion of some crates as dependencies or require special handling.\nFor example:Crates that require the architecture be a subset of the ones supported by the\nofficial toolchain. There is no workaround for this unless that crate is\nforked and BPF added to that those architecture checks.\nCrates may depend on rand which is not supported in Solana's deterministic\nprogram environment. To include a rand dependent crate refer to Depending\non Rand.\nCrates may overflow the stack even if the stack overflowing code isn't",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/developing-rust",
        "title": "developing-rust",
        "content": "included in the program itself. For more information refer to\nStack.\nHow to Build\u200bFirst setup the environment:Install the latest Rust stable from https://rustup.\nrs/Install the latest Solana command-line toolsThe normal cargo build is available for building programs against your host\nmachine which can be used for unit testing:$ cargo buildTo build a specific program, such as SPL Token, for the Solana BPF target which\ncan be deployed to the cluster:$ cd <the program directory>$ cargo build-bpfHow to Test\u200bSolana programs can be unit tested via the traditional cargo test mechanism by\nexercising program functions directly.\nTo help facilitate testing in an environment that more closely matches a live\ncluster, developers can use the\nprogram-test crate. The\nprogram-test crate starts up a local instance of the runtime and allows tests\nto send multiple transactions while keeping state for the duration of the test.\nFor more information the test in sysvar\nexample\nshows how an instruction containing sysvar account is sent and processed by the\nprogram.\nProgram Entrypoint\u200bPrograms export a known entrypoint symbol which the Solana runtime looks up and\ncalls when invoking a program. Solana supports multiple versions of the BPF\nloader and the entrypoints may vary between them.\nPrograms must be written for and deployed to the same loader. For more details\nsee the overview.\nCurrently there are two supported loaders BPF\nLoader\nand BPF loader",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/developing-rust",
        "title": "developing-rust",
        "content": "deprecatedThey both have the same raw entrypoint definition, the following is the raw\nsymbol that the runtime looks up and calls:#[no_mangle]pub unsafe extern \"C\" fn entrypoint(input: *mut u8) -> u64;This entrypoint takes a generic byte array which contains the serialized program\nparameters (program id, accounts, instruction data, etc.\n.\n.\n). To deserialize the\nparameters each loader contains its own wrapper macro that exports the raw\nentrypoint, deserializes the parameters, calls a user defined instruction\nprocessing function, and returns the results.\nYou can find the entrypoint macros here:BPF Loader's entrypoint\nmacroBPF Loader deprecated's entrypoint\nmacroThe program defined instruction processing function that the entrypoint macros\ncall must be of this form:pub type ProcessInstruction =    fn(program_id: &Pubkey, accounts: &[AccountInfo], instruction_data: &[u8]) -> ProgramResult;Refer to helloworld's use of the\nentrypoint\nas an example of how things fit together.\nParameter Deserialization\u200bEach loader provides a helper function that deserializes the program's input\nparameters into Rust types. The entrypoint macros automatically calls the\ndeserialization helper:BPF Loader\ndeserializationBPF Loader deprecated\ndeserializationSome programs may want to perform deserialization themselves and they can by\nproviding their own implementation of the raw entrypoint.\nTake note that the provided deserialization functions retain references back to",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/developing-rust",
        "title": "developing-rust",
        "content": "the serialized byte array for variables that the program is allowed to modify\n(lamports, account data). The reason for this is that upon return the loader\nwill read those modifications so they may be committed. If a program implements\ntheir own deserialization function they need to ensure that any modifications\nthe program wishes to commit be written back into the input byte array.\nDetails on how the loader serializes the program inputs can be found in the\nInput Parameter Serialization docs.\nData Types\u200bThe loader's entrypoint macros call the program defined instruction processor\nfunction with the following parameters:program_id: &Pubkey,accounts: &[AccountInfo],instruction_data: &[u8]The program id is the public key of the currently executing program.\nThe accounts is an ordered slice of the accounts referenced by the instruction\nand represented as an\nAccountInfo\nstructures. An account's place in the array signifies its meaning, for example,\nwhen transferring lamports an instruction may define the first account as the\nsource and the second as the destination.\nThe members of the AccountInfo structure are read-only except for lamports\nand data. Both may be modified by the program in accordance with the runtime\nenforcement policy. Both of\nthese members are protected by the Rust RefCell construct, so they must be\nborrowed to read or write to them. The reason for this is they both point back\nto the original input byte array, but there may be multiple entries in the",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/developing-rust",
        "title": "developing-rust",
        "content": "accounts slice that point to the same account. Using RefCell ensures that the\nprogram does not accidentally perform overlapping read/writes to the same\nunderlying data via multiple AccountInfo structures. If a program implements\ntheir own deserialization function care should be taken to handle duplicate\naccounts appropriately.\nThe instruction data is the general purpose byte array from the instruction's\ninstruction data\nbeing processed.\nHeap\u200bRust programs implement the heap directly by defining a custom\nglobal_allocatorPrograms may implement their own global_allocator based on its specific needs.\nRefer to the custom heap example for more information.\nRestrictions\u200bOn-chain Rust programs support most of Rust's libstd, libcore, and liballoc, as\nwell as many 3rd party crates.\nThere are some limitations since these programs run in a resource-constrained,\nsingle-threaded environment, and must be deterministic:No access torandstd::fsstd::netstd::futurestd::processstd::syncstd::taskstd::threadstd::timeLimited access to:std::hashstd::osBincode is extremely computationally expensive in both cycles and call depth\nand should be avoidedString formatting should be avoided since it is also computationally\nexpensive.\nNo support for println!\n, print!\n, the Solana logging helpers\nshould be used instead.\nThe runtime enforces a limit on the number of instructions a program can\nexecute during the processing of one instruction. See\ncomputation budget for more\ninformation.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/developing-rust",
        "title": "developing-rust",
        "content": "Depending on Rand\u200bPrograms are constrained to run deterministically, so random numbers are not\navailable. Sometimes a program may depend on a crate that depends itself on\nrand even if the program does not use any of the random number functionality.\nIf a program depends on rand, the compilation will fail because there is no\nget-random support for Solana. The error will typically look like this:error: target is not supported, for more information see: https://docs.\nrs/getrandom/#unsupported-targets   --> /Users/jack/.\ncargo/registry/src/github.\ncom-1ecc6299db9ec823/getrandom-0.\n1.\n14/src/lib.\nrs:257:9    |257 | /         compile_error!\n(\"\\258 | |             target is not supported, for more information see: \\259 | |             https://docs.\nrs/getrandom/#unsupported-targets\\260 | |         \");    | |___________^To work around this dependency issue, add the following dependency to the\nprogram's Cargo.\ntoml:getrandom = { version = \"0.\n1.\n14\", features = [\"dummy\"] }or if the dependency is on getrandom v0.\n2 add:getrandom = { version = \"0.\n2.\n2\", features = [\"custom\"] }Logging\u200bRust's println! macro is computationally expensive and not supported. Instead\nthe helper macro\nmsg!\nis provided.\nmsg! has two forms:msg!\n(\"A string\");ormsg!\n(0_64, 1_64, 2_64, 3_64, 4_64);Both forms output the results to the program logs. If a program so wishes they\ncan emulate println! by using format!\n:msg!\n(\"Some variable: {:?\n}\", variable);The debugging section has more information about working",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/developing-rust",
        "title": "developing-rust",
        "content": "with program logs the Rust examples contains a logging example.\nPanicking\u200bRust's panic!\n, assert!\n, and internal panic results are printed to the\nprogram logs by default.\nINFO  solana_runtime::message_processor] Finalized account CGLhHSuWsp1gT4B7MY2KACqp9RUwQRhcUFfVSuxpSajZINFO  solana_runtime::message_processor] Call BPF program CGLhHSuWsp1gT4B7MY2KACqp9RUwQRhcUFfVSuxpSajZINFO  solana_runtime::message_processor] Program log: Panicked at: 'assertion failed: `(left == right)`      left: `1`,     right: `2`', rust/panic/src/lib.\nrs:22:5INFO  solana_runtime::message_processor] BPF program consumed 5453 of 200000 unitsINFO  solana_runtime::message_processor] BPF program CGLhHSuWsp1gT4B7MY2KACqp9RUwQRhcUFfVSuxpSajZ failed: BPF program panickedCustom Panic Handler\u200bPrograms can override the default panic handler by providing their own\nimplementation.\nFirst define the custom-panic feature in the program's Cargo.\ntoml[features]default = [\"custom-panic\"]custom-panic = []Then provide a custom implementation of the panic handler:#[cfg(all(feature = \"custom-panic\", target_os = \"solana\"))]#[no_mangle]fn custom_panic(info: &core::panic::PanicInfo<'_>) {    solana_program::msg!\n(\"program custom panic enabled\");    solana_program::msg!\n(\"{}\", info);}In the above snippit, the default implementation is shown, but developers may\nreplace that with something that better suits their needs.\nOne of the side effects of supporting full panic messages by default is that",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/developing-rust",
        "title": "developing-rust",
        "content": "programs incur the cost of pulling in more of Rust's libstd implementation\ninto program's shared object. Typical programs will already be pulling in a\nfair amount of libstd and may not notice much of an increase in the shared\nobject size. But programs that explicitly attempt to be very small by avoiding\nlibstd may take a significant impact (~25kb). To eliminate that impact,\nprograms can provide their own custom panic handler with an empty\nimplementation.\n#[cfg(all(feature = \"custom-panic\", target_os = \"solana\"))]#[no_mangle]fn custom_panic(info: &core::panic::PanicInfo<'_>) {    // Do nothing to save space}Compute Budget\u200bUse the system call\nsol_log_compute_units()\nto log a message containing the remaining number of compute units the program\nmay consume before execution is haltedSee compute budget\nfor more information.\nELF Dump\u200bThe BPF shared object internals can be dumped to a text file to gain more\ninsight into a program's composition and what it may be doing at runtime. The\ndump will contain both the ELF information as well as a list of all the symbols\nand the instructions that implement them. Some of the BPF loader's error log\nmessages will reference specific instruction numbers where the error occurred.\nThese references can be looked up in the ELF dump to identify the offending\ninstruction and its context.\nTo create a dump file:$ cd <program directory>$ cargo build-bpf --dumpExamples\u200bThe Solana Program Library\ngithub\nrepo contains a collection of Rust examples.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/examples",
        "title": "examples",
        "content": "Program ExamplesHelloworld\u200bHello World is a project that demonstrates how to use the Solana Javascript API\nand both Rust and C programs to build, deploy, and interact with programs on the\nSolana blockchain.\nThe project comprises of:An on-chain hello world programA client that can send a \"hello\" to an account and get back the number of\ntimes \"hello\" has been sentBuild and Run\u200bFirst fetch the latest version of the example code:$ git clone https://github.\ncom/solana-labs/example-helloworld.\ngit$ cd example-helloworldNext, follow the steps in the git repository's\nREADME.\nBreak\u200bBreak is a React app that gives users a visceral\nfeeling for just how fast and high-performance the Solana network really is. Can\nyou break the Solana blockchain? During a 15 second play-though, each click of\na button or keystroke sends a new transaction to the cluster. Smash the keyboard\nas fast as you can and watch your transactions get finalized in real time while\nthe network takes it all in stride!\nBreak can be played on our Devnet, Testnet and Mainnet Beta networks. Plays are\nfree on Devnet and Testnet, where the session is funded by a network faucet. On\nMainnet Beta, users pay to play 0.\n08 SOL per game. The session account can be\nfunded by a local keystore wallet or by scanning a QR code from Trust Wallet to\ntransfer the tokens.\nClick here to play BreakBuild and Run\u200bFirst fetch the latest version of the example code:$ git clone https://github.\ncom/solana-labs/break.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/examples",
        "title": "examples",
        "content": "git$ cd breakNext, follow the steps in the git repository's\nREADME.\nLanguage Specific\u200bRustC",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/faq",
        "title": "faq",
        "content": "FAQWhen writing or interacting with Solana programs, there are common questions or\nchallenges that often come up. Below are resources to help answer these\nquestions.\nIf not addressed here, ask on StackOverflow with the solana tag or check out the Solana #developer-supportCallDepth error\u200bThis error means that that cross-program invocation exceeded the allowed\ninvocation call depth.\nSee cross-program invocation Call\nDepthCallDepthExceeded error\u200bThis error means the BPF stack depth was exceeded.\nSee call depthComputational constraints\u200bSee computational\nconstraintsFloat Rust types\u200bSee float supportHeap size\u200bSee heapInvalidAccountData\u200bThis program error can happen for a lot of reasons. Usually, it's caused by\npassing an account to the program that the program is not expecting, either in\nthe wrong position in the instruction or an account not compatible with the\ninstruction being executed.\nAn implementation of a program might also cause this error when performing a\ncross-program instruction and forgetting to provide the account for the program\nthat you are calling.\nInvalidInstructionData\u200bThis program error can occur while trying to deserialize the instruction, check\nthat the structure passed in matches exactly the instruction. There may be some\npadding between fields. If the program implements the Rust Pack trait then try\npacking and unpacking the instruction type T to determine the exact encoding\nthe program expects:https://github.\ncom/solana-labs/solana/blob/v1.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/faq",
        "title": "faq",
        "content": "4/sdk/program/src/program_pack.\nrsMissingRequiredSignature\u200bSome instructions require the account to be a signer; this error is returned if\nan account is expected to be signed but is not.\nAn implementation of a program might also cause this error when performing a\ncross-program invocation that requires a signed program address, but the passed\nsigner seeds passed to invoke_signed\ndon't match the signer seeds used to create the program address\ncreate_program_address.\nrand Rust dependency causes compilation failure\u200bSee Rust Project DependenciesRust restrictions\u200bSee Rust restrictionsStack size\u200bSee stack",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/overview",
        "title": "overview",
        "content": "OverviewDevelopers can write and deploy their own programs to the Solana blockchain.\nThe Helloworld example is a good starting place to see\nhow a program is written, built, deployed, and interacted with on-chain.\nBerkeley Packet Filter (BPF)\u200bSolana on-chain programs are compiled via the LLVM compiler\ninfrastructure to an Executable and Linkable Format\n(ELF) containing\na variation of the Berkeley Packet Filter\n(BPF) bytecode.\nBecause Solana uses the LLVM compiler infrastructure, a program may be written\nin any programming language that can target the LLVM's BPF backend. Solana\ncurrently supports writing programs in Rust and C/C++.\nBPF provides an efficient instruction\nset that can be\nexecuted in an interpreted virtual machine or as efficient just-in-time compiled\nnative instructions.\nMemory map\u200bThe virtual address memory map used by Solana BPF programs is fixed and laid out\nas followsProgram code starts at 0x100000000Stack data starts at 0x200000000Heap data starts at 0x300000000Program input parameters start at 0x400000000The above virtual addresses are start addresses but programs are given access to\na subset of the memory map. The program will panic if it attempts to read or\nwrite to a virtual address that it was not granted access to, and an\nAccessViolation error will be returned that contains the address and size of\nthe attempted violation.\nStack\u200bBPF uses stack frames instead of a variable stack pointer. Each stack frame is\n4KB in size.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/overview",
        "title": "overview",
        "content": "If a program violates that stack frame size, the compiler will report the\noverrun as a warning.\nFor example: Error: Function _ZN16curve25519_dalek7edwards21EdwardsBasepointTable6create17h178b3d2411f7f082E Stack offset of -30728 exceeded max offset of -4096 by 26632 bytes, please minimize large stack variablesThe message identifies which symbol is exceeding its stack frame but the name\nmight be mangled if it is a Rust or C++ symbol. To demangle a Rust symbol use\nrustfilt. The above warning came from a\nRust program, so the demangled symbol name is:$ rustfilt _ZN16curve25519_dalek7edwards21EdwardsBasepointTable6create17h178b3d2411f7f082Ecurve25519_dalek::edwards::EdwardsBasepointTable::createTo demangle a C++ symbol use c++filt from binutils.\nThe reason a warning is reported rather than an error is because some dependent\ncrates may include functionality that violates the stack frame restrictions even\nif the program doesn't use that functionality. If the program violates the stack\nsize at runtime, an AccessViolation error will be reported.\nBPF stack frames occupy a virtual address range starting at 0x200000000.\nCall Depth\u200bPrograms are constrained to run quickly, and to facilitate this, the program's\ncall stack is limited to a max depth of 64 frames.\nHeap\u200bPrograms have access to a runtime heap either directly in C or via the Rust\nalloc APIs. To facilitate fast allocations, a simple 32KB bump heap is\nutilized. The heap does not support free or realloc so use it wisely.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/overview",
        "title": "overview",
        "content": "Internally, programs have access to the 32KB memory region starting at virtual\naddress 0x300000000 and may implement a custom heap based on the program's\nspecific needs.\nRust program heap usageC program heap usageFloat Support\u200bPrograms support a limited subset of Rust's float operations, if a program\nattempts to use a float operation that is not supported, the runtime will report\nan unresolved symbol error.\nFloat operations are performed via software libraries, specifically LLVM's float\nbuiltins. Due to the software emulated they consume more compute units than\ninteger operations. In general, fixed point operations are recommended where\npossible.\nThe Solana Program Library math tests will report the performance of some math\noperations:\nhttps://github.\ncom/solana-labs/solana-program-library/tree/master/libraries/mathTo run the test, sync the repo, and run:$ cargo test-bpf -- --nocapture --test-threads=1Recent results show the float operations take more instructions compared to\nintegers equivalents. Fixed point implementations may vary but will also be\nless than the float equivalents:         u64   f32Multipy    8   176Divide     9   219Static Writable Data\u200bProgram shared objects do not support writable shared data. Programs are shared\nbetween multiple parallel executions using the same shared read-only code and\ndata. This means that developers should not include any static writable or\nglobal variables in programs. In the future a copy-on-write mechanism could be",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/overview",
        "title": "overview",
        "content": "added to support writable data.\nSigned division\u200bThe BPF instruction set does not support signed\ndivision.\nAdding a signed division instruction is a consideration.\nLoaders\u200bPrograms are deployed with and executed by runtime loaders, currently there are\ntwo supported loaders BPF\nLoader\nand BPF loader\ndeprecatedLoaders may support different application binary interfaces so developers must\nwrite their programs for and deploy them to the same loader. If a program\nwritten for one loader is deployed to a different one the result is usually a\nAccessViolation error due to mismatched deserialization of the program's input\nparameters.\nFor all practical purposes program should always be written to target the latest\nBPF loader and the latest loader is the default for the command-line interface\nand the javascript APIs.\nFor language specific information about implementing a program for a particular\nloader see:Rust program entrypointsC program entrypointsDeployment\u200bBPF program deployment is the process of uploading a BPF shared object into a\nprogram account's data and marking the account executable. A client breaks the\nBPF shared object into smaller pieces and sends them as the instruction data of\nWrite\ninstructions to the loader where loader writes that data into the program's\naccount data. Once all the pieces are received the client sends a\nFinalize\ninstruction to the loader, the loader then validates that the BPF data is valid",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/overview",
        "title": "overview",
        "content": "and marks the program account as executable. Once the program account is\nmarked executable, subsequent transactions may issue instructions for that\nprogram to process.\nWhen an instruction is directed at an executable BPF program the loader\nconfigures the program's execution environment, serializes the program's input\nparameters, calls the program's entrypoint, and reports any errors encountered.\nFor further information see deployingInput Parameter Serialization\u200bBPF loaders serialize the program input parameters into a byte array that is\nthen passed to the program's entrypoint, where the program is responsible for\ndeserializing it on-chain. One of the changes between the deprecated loader and\nthe current loader is that the input parameters are serialized in a way that\nresults in various parameters falling on aligned offsets within the aligned byte\narray. This allows deserialization implementations to directly reference the\nbyte array and provide aligned pointers to the program.\nFor language specific information about serialization see:Rust program parameter\ndeserializationC program parameter\ndeserializationThe latest loader serializes the program input parameters as follows (all\nencoding is little endian):8 bytes unsigned number of accountsFor each account1 byte indicating if this is a duplicate account, if not a duplicate then\nthe value is 0xff, otherwise the value is the index of the account it is a\nduplicate of.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/on-chain-programs/overview",
        "title": "overview",
        "content": "If duplicate: 7 bytes of paddingIf not duplicate:1 byte boolean, true if account is a signer1 byte boolean, true if account is writable1 byte boolean, true if account is executable4 bytes of padding32 bytes of the account public key32 bytes of the account's owner public key8 bytes unsigned number of lamports owned by the account8 bytes unsigned number of bytes of account datax bytes of account data10k bytes of padding, used for reallocenough padding to align the offset to 8 bytes.\n8 bytes rent epoch8 bytes of unsigned number of instruction datax bytes of instruction data32 bytes of the program id",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/accounts",
        "title": "accounts",
        "content": "AccountsStoring State between Transactions\u200bIf the program needs to store state between transactions, it does so using\naccounts. Accounts are similar to files in operating systems such as Linux in\nthat they may hold arbitrary data that persists beyond\nthe lifetime of a program. Also like a file, an account includes metadata that\ntells the runtime who is allowed to access the data and how.\nUnlike a file, the account includes metadata for the lifetime of the file. That\nlifetime is expressed by a number of fractional native\ntokens called lamports. Accounts are held in validator memory and pay\n\"rent\" to stay there. Each validator periodically scans all accounts\nand collects rent. Any account that drops to zero lamports is purged. Accounts\ncan also be marked rent-exempt if they contain a sufficient\nnumber of lamports.\nIn the same way that a Linux user uses a path to look up a file, a Solana client\nuses an address to look up an account. The address is a 256-bit public key.\nSigners\u200bTransactions include one or more digital signatures\neach corresponding to an account address referenced by the transaction. Each of these\naddresses must be the public key of an ed25519 keypair, and the signature signifies\nthat the holder of the matching private key signed, and thus, \"authorized\" the transaction.\nIn this case, the account is referred to as a signer. Whether an account is a signer or not\nis communicated to the program as part of the account's metadata. Programs can",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/accounts",
        "title": "accounts",
        "content": "then use that information to make authority decisions.\nRead-only\u200bTransactions can indicate that some of\nthe accounts it references be treated as read-only accounts in order to enable\nparallel account processing between transactions. The runtime permits read-only\naccounts to be read concurrently by multiple programs. If a program attempts to\nmodify a read-only account, the transaction is rejected by the runtime.\nExecutable\u200bIf an account is marked \"executable\" in its metadata, then it is considered a\nprogram which can be executed by including the account's public key in an\ninstruction's program id. Accounts are marked as\nexecutable during a successful program deployment process by the loader that\nowns the account. When a program is deployed to the execution engine (BPF deployment),\nthe loader determines that the bytecode in the account's data is valid.\nIf so, the loader permanently marks the program account as executable.\nIf a program is marked as final (non-upgradeable), the runtime enforces that the\naccount's data (the program) is immutable. Through the upgradeable loader, it is\npossible to upload a totally new program to an existing program address.\nCreating\u200bTo create an account, a client generates a keypair and registers its public key\nusing the SystemProgram::CreateAccount instruction with a fixed\nstorage size in bytes preallocated.\nThe current maximum size of an account's data is 10 MiB, which can be changed",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/accounts",
        "title": "accounts",
        "content": "(increased or decreased) at a rate over all accounts of 20 MiB per transaction,\nand the size can be increased by 10 KiB per account and per instruction.\nAn account address can be any arbitrary 256 bit value, and there are mechanisms\nfor advanced users to create derived addresses\n(SystemProgram::CreateAccountWithSeed,\nPubkey::CreateProgramAddress).\nAccounts that have never been created via the system program can also be passed\nto programs. When an instruction references an account that hasn't been\npreviously created, the program will be passed an account with no data and zero lamports\nthat is owned by the system program.\nSuch newly created accounts reflect\nwhether they sign the transaction, and therefore, can be used as an\nauthority. Authorities in this context convey to the program that the holder of\nthe private key associated with the account's public key signed the transaction.\nThe account's public key may be known to the program or recorded in another\naccount, signifying some kind of ownership or authority over an asset or\noperation the program controls or performs.\nOwnership and Assignment to Programs\u200bA created account is initialized to be owned by a built-in program called the\nSystem program and is called a system account aptly. An account includes\n\"owner\" metadata. The owner is a program id. The runtime grants the program\nwrite access to the account if its id matches the owner. For the case of the",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/accounts",
        "title": "accounts",
        "content": "System program, the runtime allows clients to transfer lamports and importantly\nassign account ownership, meaning changing the owner to a different program id. If\nan account is not owned by a program, the program is only permitted to read its\ndata and credit the account.\nVerifying validity of unmodified, reference-only accounts\u200bFor security purposes, it is recommended that programs check the validity of any\naccount it reads, but does not modify.\nThis is because a malicious user\ncould create accounts with arbitrary data and then pass these accounts to the\nprogram in place of valid accounts. The arbitrary data could be crafted in\na way that leads to unexpected or harmful program behavior.\nThe security model enforces that an account's data can only be modified by the\naccount's Owner program. This allows the program to trust that the data\nis passed to them via accounts they own. The\nruntime enforces this by rejecting any transaction containing a program that\nattempts to write to an account it does not own.\nIf a program were to not check account validity, it might read an account\nit thinks it owns, but doesn't. Anyone can\nissue instructions to a program, and the runtime does not know that those\naccounts are expected to be owned by the program.\nTo check an account's validity, the program should either check the account's\naddress against a known value, or check that the account is indeed owned\ncorrectly (usually owned by the program itself).",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/accounts",
        "title": "accounts",
        "content": "One example is when programs use a sysvar account. Unless the program checks the\naccount's address or owner, it's impossible to be sure whether it's a real and\nvalid sysvar account merely by successful deserialization of the account's data.\nAccordingly, the Solana SDK checks the sysvar account's validity during\ndeserialization.\nAn alternative and safer way to read a sysvar is via the sysvar's get()\nfunction\nwhich doesn't require these checks.\nIf the program always modifies the account in question, the address/owner check\nisn't required because modifying an unowned account will be rejected by the runtime,\nand the containing transaction will be thrown out.\nRent\u200bKeeping accounts alive on Solana incurs a storage cost called rent because the\nblockchain cluster must actively maintain the data to process any future transactions.\nThis is different from Bitcoin and Ethereum, where storing accounts doesn't\nincur any costs.\nCurrently, all new accounts are required to be rent-exempt.\nRent exemption\u200bAn account is considered rent-exempt if it holds at least 2 years worth of rent.\nThis is checked every time an account's balance is reduced, and transactions\nthat would reduce the balance to below the minimum amount will fail.\nProgram executable accounts are required by the runtime to be rent-exempt to\navoid being purged.\ninfoUse the getMinimumBalanceForRentExemption RPC\nendpoint to calculate the\nminimum balance for a particular account size. The following calculation is\nillustrative only.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/accounts",
        "title": "accounts",
        "content": "For example, a program executable with the size of 15,000 bytes requires a\nbalance of 105,290,880 lamports (=~ 0.\n105 SOL) to be rent-exempt:105,290,880 = 19.\n055441478439427 (fee rate) * (128 + 15_000)(account size including metadata) * ((365.\n25/2) * 2)(epochs in 2 years)Rent can also be estimated via the solana rent CLI subcommand$ solana rent 15000Rent per byte-year: 0.\n00000348 SOLRent per epoch: 0.\n000288276 SOLRent-exempt minimum: 0.\n10529088 SOLNote: Rest assured that, should the storage rent rate need to be increased at some\npoint in the future, steps will be taken to ensure that accounts that are rent-exempt\nbefore the increase will remain rent-exempt afterwards",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/calling-between-programs",
        "title": "calling-between-programs",
        "content": "Calling Between ProgramsCross-Program Invocations\u200bThe Solana runtime allows programs to call each other via a mechanism called\ncross-program invocation. Calling between programs is achieved by one program\ninvoking an instruction of the other. The invoking program is halted until the\ninvoked program finishes processing the instruction.\nFor example, a client could create a transaction that modifies two accounts,\neach owned by separate on-chain programs:let message = Message::new(vec!\n[    token_instruction::pay(&alice_pubkey),    acme_instruction::launch_missiles(&bob_pubkey),]);client.\nsend_and_confirm_message(&[&alice_keypair, &bob_keypair], &message);A client may instead allow the acme program to conveniently invoke token\ninstructions on the client's behalf:let message = Message::new(vec!\n[    acme_instruction::pay_and_launch_missiles(&alice_pubkey, &bob_pubkey),]);client.\nsend_and_confirm_message(&[&alice_keypair, &bob_keypair], &message);Given two on-chain programs, token and acme, each implementing instructions\npay() and launch_missiles() respectively, acme can be implemented with a\ncall to a function defined in the token module by issuing a cross-program\ninvocation:mod acme {    use token_instruction;    fn launch_missiles(accounts: &[AccountInfo]) -> Result<()> {        .\n.\n.    }    fn pay_and_launch_missiles(accounts: &[AccountInfo]) -> Result<()> {        let alice_pubkey = accounts[1].",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/calling-between-programs",
        "title": "calling-between-programs",
        "content": "key;        let instruction = token_instruction::pay(&alice_pubkey);        invoke(&instruction, accounts)?\n;        launch_missiles(accounts)?\n;    }invoke() is built into Solana's runtime and is responsible for routing the\ngiven instruction to the token program via the instruction's program_id\nfield.\nNote that invoke requires the caller to pass all the accounts required by the\ninstruction being invoked, except for the executable account (the program_id).\nBefore invoking pay(), the runtime must ensure that acme didn't modify any\naccounts owned by token. It does this by applying the runtime's policy to the\ncurrent state of the accounts at the time acme calls invoke vs. the initial\nstate of the accounts at the beginning of the acme's instruction. After\npay() completes, the runtime must again ensure that token didn't modify any\naccounts owned by acme by again applying the runtime's policy, but this time\nwith the token program ID. Lastly, after pay_and_launch_missiles()\ncompletes, the runtime must apply the runtime policy one more time where it\nnormally would, but using all updated pre_* variables. If executing\npay_and_launch_missiles() up to pay() made no invalid account changes,\npay() made no invalid changes, and executing from pay() until\npay_and_launch_missiles() returns made no invalid changes, then the runtime\ncan transitively assume pay_and_launch_missiles() as a whole made no invalid\naccount changes, and therefore commit all these account modifications.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/calling-between-programs",
        "title": "calling-between-programs",
        "content": "Instructions that require privileges\u200bThe runtime uses the privileges granted to the caller program to determine what\nprivileges can be extended to the callee. Privileges in this context refer to\nsigners and writable accounts. For example, if the instruction the caller is\nprocessing contains a signer or writable account, then the caller can invoke an\ninstruction that also contains that signer and/or writable account.\nThis privilege extension relies on the fact that programs are immutable, except\nduring the special case of program upgrades.\nIn the case of the acme program, the runtime can safely treat the transaction's\nsignature as a signature of a token instruction. When the runtime sees the\ntoken instruction references alice_pubkey, it looks up the key in the acme\ninstruction to see if that key corresponds to a signed account. In this case, it\ndoes and thereby authorizes the token program to modify Alice's account.\nProgram signed accounts\u200bPrograms can issue instructions that contain signed accounts that were not\nsigned in the original transaction by using Program derived\naddresses.\nTo sign an account with program derived addresses, a program may\ninvoke_signed().        invoke_signed(            &instruction,            accounts,            &[&[\"First addresses seed\"],              &[\"Second addresses first seed\", \"Second addresses second seed\"]],        )?\n;Call Depth\u200bCross-program invocations allow programs to invoke other programs directly, but",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/calling-between-programs",
        "title": "calling-between-programs",
        "content": "the depth is constrained currently to 4.\nReentrancy\u200bReentrancy is currently limited to direct self recursion, capped at a fixed\ndepth. This restriction prevents situations where a program might invoke another\nfrom an intermediary state without the knowledge that it might later be called\nback into. Direct recursion gives the program full control of its state at the\npoint that it gets called back.\nProgram Derived Addresses\u200bProgram derived addresses allow programmatically generated signatures to be used\nwhen calling between programs.\nUsing a program derived address, a program may be given the authority over an\naccount and later transfer that authority to another. This is possible because\nthe program can act as the signer in the transaction that gives authority.\nFor example, if two users want to make a wager on the outcome of a game in\nSolana, they must each transfer their wager's assets to some intermediary that\nwill honor their agreement. Currently, there is no way to implement this\nintermediary as a program in Solana because the intermediary program cannot\ntransfer the assets to the winner.\nThis capability is necessary for many DeFi applications since they require\nassets to be transferred to an escrow agent until some event occurs that\ndetermines the new owner.\nDecentralized Exchanges that transfer assets between matching bid and ask\norders.\nAuctions that transfer assets to the winner.\nGames or prediction markets that collect and redistribute prizes to the\nwinners.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/calling-between-programs",
        "title": "calling-between-programs",
        "content": "Program derived address:Allow programs to control specific addresses, called program addresses, in\nsuch a way that no external user can generate valid transactions with\nsignatures for those addresses.\nAllow programs to programmatically sign for program addresses that are\npresent in instructions invoked via Cross-Program Invocations.\nGiven the two conditions, users can securely transfer or assign the authority of\non-chain assets to program addresses, and the program can then assign that\nauthority elsewhere at its discretion.\nPrivate keys for program addresses\u200bA program address does not lie on the ed25519 curve and therefore has no valid\nprivate key associated with it, and thus generating a signature for it is\nimpossible. While it has no private key of its own, it can be used by a program\nto issue an instruction that includes the program address as a signer.\nHash-based generated program addresses\u200bProgram addresses are deterministically derived from a collection of seeds and a\nprogram id using a 256-bit pre-image resistant hash function. Program address\nmust not lie on the ed25519 curve to ensure there is no associated private key.\nDuring generation, an error will be returned if the address is found to lie on\nthe curve. There is about a 50/50 chance of this happening for a given\ncollection of seeds and program id. If this occurs a different set of seeds or\na seed bump (additional 8 bit seed) can be used to find a valid program address\noff the curve.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/calling-between-programs",
        "title": "calling-between-programs",
        "content": "Deterministic program addresses for programs follow a similar derivation path as\nAccounts created with SystemInstruction::CreateAccountWithSeed which is\nimplemented with Pubkey::create_with_seed.\nFor reference, that implementation is as follows:pub fn create_with_seed(    base: &Pubkey,    seed: &str,    program_id: &Pubkey,) -> Result<Pubkey, SystemError> {    if seed.\nlen() > MAX_ADDRESS_SEED_LEN {        return Err(SystemError::MaxSeedLengthExceeded);    }    Ok(Pubkey::new(        hashv(&[base.\nas_ref(), seed.\nas_ref(), program_id.\nas_ref()]).\nas_ref(),    ))}Programs can deterministically derive any number of addresses by using seeds.\nThese seeds can symbolically identify how the addresses are used.\nFrom Pubkey::/// Generate a derived program address///     * seeds, symbolic keywords used to derive the key///     * program_id, program that the address is derived forpub fn create_program_address(    seeds: &[&[u8]],    program_id: &Pubkey,) -> Result<Pubkey, PubkeyError>/// Find a valid off-curve derived program address and its bump seed///     * seeds, symbolic keywords used to derive the key///     * program_id, program that the address is derived forpub fn find_program_address(    seeds: &[&[u8]],    program_id: &Pubkey,) -> Option<(Pubkey, u8)> {    let mut bump_seed = [std::u8::MAX];    for _ in 0.\n.\nstd::u8::MAX {        let mut seeds_with_bump = seeds.\nto_vec();        seeds_with_bump.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/calling-between-programs",
        "title": "calling-between-programs",
        "content": "push(&bump_seed);        if let Ok(address) = create_program_address(&seeds_with_bump, program_id) {            return Some((address, bump_seed[0]));        }        bump_seed[0] -= 1;    }    None} Warning: Because of the way the seeds are hashed there is a potential for\nprogram address collisions for the same program id.  The seeds are hashed\nsequentially which means that seeds {\"abcdef\"}, {\"abc\", \"def\"}, and {\"ab\",\n\"cd\", \"ef\"} will all result in the same program address given the same program\nid. Since the chance of collision is local to a given program id, the developer\nof that program must take care to choose seeds that do not collide with each\nother. For seed schemes that are susceptible to this type of hash collision, a\ncommon remedy is to insert separators between seeds, e.\ng. transforming {\"abc\",\n\"def\"} into {\"abc\", \"-\", \"def\"}.\nUsing program addresses\u200bClients can use the create_program_address function to generate a destination\naddress. In this example, we assume that\ncreate_program_address(&[&[\"escrow\"]], &escrow_program_id) generates a valid\nprogram address that is off the curve.\n// deterministically derive the escrow keylet escrow_pubkey = create_program_address(&[&[\"escrow\"]], &escrow_program_id);// construct a transfer message using that keylet message = Message::new(vec!\n[    token_instruction::transfer(&alice_pubkey, &escrow_pubkey, 1),]);// process the message which transfer one 1 token to the escrowclient.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/calling-between-programs",
        "title": "calling-between-programs",
        "content": "send_and_confirm_message(&[&alice_keypair], &message);Programs can use the same function to generate the same address. In the function\nbelow the program issues a token_instruction::transfer from a program address\nas if it had the private key to sign the transaction.\nfn transfer_one_token_from_escrow(    program_id: &Pubkey,    accounts: &[AccountInfo],) -> ProgramResult {    // User supplies the destination    let alice_pubkey = keyed_accounts[1].\nunsigned_key();    // Deterministically derive the escrow pubkey.    let escrow_pubkey = create_program_address(&[&[\"escrow\"]], program_id);    // Create the transfer instruction    let instruction = token_instruction::transfer(&escrow_pubkey, &alice_pubkey, 1);    // The runtime deterministically derives the key from the currently    // executing program ID and the supplied keywords.    // If the derived address matches a key marked as signed in the instruction    // then that key is accepted as signed.    invoke_signed(&instruction, accounts, &[&[\"escrow\"]])}Note that the address generated using create_program_address is not guaranteed\nto be a valid program address off the curve. For example, let's assume that the\nseed \"escrow2\" does not generate a valid program address.\nTo generate a valid program address using \"escrow2\" as a seed, use\nfind_program_address, iterating through possible bump seeds until a valid",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/calling-between-programs",
        "title": "calling-between-programs",
        "content": "combination is found. The preceding example becomes:// find the escrow key and valid bump seedlet (escrow_pubkey2, escrow_bump_seed) = find_program_address(&[&[\"escrow2\"]], &escrow_program_id);// construct a transfer message using that keylet message = Message::new(vec!\n[    token_instruction::transfer(&alice_pubkey, &escrow_pubkey2, 1),]);// process the message which transfer one 1 token to the escrowclient.\nsend_and_confirm_message(&[&alice_keypair], &message);Within the program, this becomes:fn transfer_one_token_from_escrow2(    program_id: &Pubkey,    accounts: &[AccountInfo],) -> ProgramResult {    // User supplies the destination    let alice_pubkey = keyed_accounts[1].\nunsigned_key();    // Iteratively derive the escrow pubkey    let (escrow_pubkey2, bump_seed) = find_program_address(&[&[\"escrow2\"]], program_id);    // Create the transfer instruction    let instruction = token_instruction::transfer(&escrow_pubkey2, &alice_pubkey, 1);    // Include the generated bump seed to the list of all seeds    invoke_signed(&instruction, accounts, &[&[\"escrow2\", &[bump_seed]]])}Since find_program_address requires iterating over a number of calls to\ncreate_program_address, it may use more\ncompute budget when\nused on-chain. To reduce the compute cost, use find_program_address off-chain\nand pass the resulting bump seed to the program.\nInstructions that require signers\u200bThe addresses generated with create_program_address and find_program_address",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/calling-between-programs",
        "title": "calling-between-programs",
        "content": "are indistinguishable from any other public key. The only way for the runtime to\nverify that the address belongs to a program is for the program to supply the\nseeds used to generate the address.\nThe runtime will internally call create_program_address, and compare the\nresult against the addresses supplied in the instruction.\nExamples\u200bRefer to Developing with\nRust\nand Developing with\nC\nfor examples of how to use cross-program invocation.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/runtime",
        "title": "runtime",
        "content": "RuntimeCapability of Programs\u200bThe runtime only permits the owner program to debit the account or modify its\ndata. The program then defines additional rules for whether the client can\nmodify accounts it owns. In the case of the System program, it allows users to\ntransfer lamports by recognizing transaction signatures. If it sees the client\nsigned the transaction using the keypair's private key, it knows the client\nauthorized the token transfer.\nIn other words, the entire set of accounts owned by a given program can be\nregarded as a key-value store, where a key is the account address and value is\nprogram-specific arbitrary binary data. A program author can decide how to\nmanage the program's whole state, possibly as many accounts.\nAfter the runtime executes each of the transaction's instructions, it uses the\naccount metadata to verify that the access policy was not violated. If a program\nviolates the policy, the runtime discards all account changes made by all\ninstructions in the transaction, and marks the transaction as failed.\nPolicy\u200bAfter a program has processed an instruction, the runtime verifies that the\nprogram only performed operations it was permitted to, and that the results\nadhere to the runtime policy.\nThe policy is as follows:Only the owner of the account may change owner.\nAnd only if the account is writable.\nAnd only if the account is not executable.\nAnd only if the data is zero-initialized or empty.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/runtime",
        "title": "runtime",
        "content": "An account not assigned to the program cannot have its balance decrease.\nThe balance of read-only and executable accounts may not change.\nOnly the owner may change account size and data.\nAnd if the account is writable.\nAnd if the account is not executable.\nExecutable is one-way (false->true) and only the account owner may set it.\nNo one can make modifications to the rent_epoch associated with this account.\nBalancing the balances\u200bBefore and after each instruction, the sum of all account balances must stay the same.\nE.\ng. if one account's balance is increased, another's must be decreased by the same amount.\nBecause the runtime can not see changes to accounts which were not passed to it,\nall accounts for which the balances were modified must be passed,\neven if they are not needed in the called instruction.\nCompute Budget\u200bTo prevent abuse of computational resources, each transaction is allocated a\ncompute budget. The budget specifies a maximum number of compute units that a\ntransaction can consume, the costs associated with different types of operations\nthe transaction may perform, and operational bounds the transaction must adhere\nto.\nAs the transaction is processed compute units are consumed by its\ninstruction's programs performing operations such as executing BPF instructions,\ncalling syscalls, etc.\n.\n. When the transaction consumes its entire budget, or\nexceeds a bound such as attempting a call stack that is too deep, the runtime",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/runtime",
        "title": "runtime",
        "content": "halts the transaction processing and returns an error.\nThe following operations incur a compute cost:Executing BPF instructionsPassing data between programsCalling system callsloggingcreating program addressescross-program invocations.\n.\n.\nFor cross-program invocations, the instructions invoked inherit the budget of\ntheir parent. If an invoked instruction consumes the transactions remaining\nbudget, or exceeds a bound, the entire invocation chain and the top level\ntransaction processing are halted.\nThe current compute\nbudget can be found in the Solana Program Runtime.\nExample Compute Budget\u200bFor example, if the compute budget set in the Solana runtime is:max_units: 1,400,000,log_u64_units: 100,create_program address units: 1500,invoke_units: 1000,max_invoke_depth: 4,max_call_depth: 64,stack_frame_size: 4096,log_pubkey_units: 100,.\n.\n.\nThen any transaction:Could execute 1,400,000 BPF instructions, if it did nothing else.\nCannot exceed 4k of stack usage.\nCannot exceed a BPF call depth of 64.\nCannot exceed 4 levels of cross-program invocations.\nNOTE: Since the compute budget is consumed incrementally as the transaction executes,\nthe total budget consumption will be a combination of the various costs of the\noperations it performs.\nAt runtime a program may log how much of the compute budget remains. See\ndebugging\nfor more information.\nPrioritization fees\u200bA transaction may set the maximum number of compute units it is allowed to",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/runtime",
        "title": "runtime",
        "content": "consume and the compute unit price by including a SetComputeUnitLimit and a\nSetComputeUnitPrice\nCompute budget instructions\nrespectively.\nIf no SetComputeUnitLimit is provided the limit will be calculated as the\nproduct of the number of instructions in the transaction (excluding the Compute\nbudget instructions) and the default per-instruction units, which is currently 200k.\nNOTE: A transaction's prioritization fee is calculated by multiplying the\nnumber of compute units by the compute unit price (measured in micro-lamports)\nset by the transaction via compute budget instructions.\nTransactions should request the minimum amount of compute units required for execution to minimize\nfees. Also note that fees are not adjusted when the number of requested compute\nunits exceeds the number of compute units actually consumed by an executed\ntransaction.\nCompute Budget instructions don't require any accounts and don't consume any\ncompute units to process. Transactions can only contain one of each type of\ncompute budget instruction, duplicate types will result in an error.\nThe ComputeBudgetInstruction::set_compute_unit_limit and\nComputeBudgetInstruction::set_compute_unit_price functions can be used to\ncreate these instructions:let instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);let instruction = ComputeBudgetInstruction::set_compute_unit_price(1);New Features\u200bAs Solana evolves, new features or patches may be introduced that changes the",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/runtime",
        "title": "runtime",
        "content": "behavior of the cluster and how programs run. Changes in behavior must be\ncoordinated between the various nodes of the cluster. If nodes do not\ncoordinate, then these changes can result in a break-down of consensus. Solana\nsupports a mechanism called runtime features to facilitate the smooth adoption\nof changes.\nRuntime features are epoch coordinated events where one or more behavior changes\nto the cluster will occur. New changes to Solana that will change behavior are\nwrapped with feature gates and disabled by default. The Solana tools are then\nused to activate a feature, which marks it pending, once marked pending the\nfeature will be activated at the next epoch.\nTo determine which features are activated use the Solana command-line\ntools:solana feature statusIf you encounter problems, first ensure that the Solana tools version you are\nusing match the version returned by solana cluster-version. If they do not\nmatch, install the correct tool suite.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/transactions",
        "title": "transactions",
        "content": "TransactionsProgram execution begins with a transaction being\nsubmitted to the cluster. The Solana runtime will execute a program to process\neach of the instructions contained in the\ntransaction, in order, and atomically.\nAnatomy of a Transaction\u200bThis section covers the binary format of a transaction.\nTransaction Format\u200bA transaction contains a compact-array of signatures,\nfollowed by a message. Each item in the signatures array is\na digital signature of the given message. The Solana\nruntime verifies that the number of signatures matches the number in the first\n8 bits of the message header. It also verifies that\neach signature was signed by the private key corresponding to the public key at\nthe same index in the message's account addresses array.\nSignature Format\u200bEach digital signature is in the ed25519 binary format and consumes 64 bytes.\nMessage Format\u200bA message contains a header, followed by a\ncompact-array of account addresses, followed by a\nrecent blockhash, followed by a compact-array of\ninstructions.\nMessage Header Format\u200bThe message header contains three unsigned 8-bit values. The first value is the\nnumber of required signatures in the containing transaction. The second value\nis the number of those corresponding account addresses that are read-only. The\nthird value in the message header is the number of read-only account addresses\nnot requiring signatures.\nAccount Addresses Format\u200bThe addresses that require signatures appear at the beginning of the account",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/transactions",
        "title": "transactions",
        "content": "address array, with addresses requesting read-write access first, and read-only\naccounts following. The addresses that do not require signatures follow the\naddresses that do, again with read-write accounts first and read-only accounts\nfollowing.\nBlockhash Format\u200bA blockhash contains a 32-byte SHA-256 hash. It is used to indicate when a\nclient last observed the ledger. Validators will reject transactions when the\nblockhash is too old.\nInstruction Format\u200bAn instruction contains a program id index, followed by a compact-array of\naccount address indexes, followed by a compact-array of opaque 8-bit data. The\nprogram id index is used to identify an on-chain program that can interpret the\nopaque data. The program id index is an unsigned 8-bit index to an account\naddress in the message's array of account addresses. The account address\nindexes are each an unsigned 8-bit index into that same array.\nCompact-Array Format\u200bA compact-array is serialized as the array length, followed by each array item.\nThe array length is a special multi-byte encoding called compact-u16.\nCompact-u16 Format\u200bA compact-u16 is a multi-byte encoding of 16 bits. The first byte contains the\nlower 7 bits of the value in its lower 7 bits. If the value is above 0x7f, the\nhigh bit is set and the next 7 bits of the value are placed into the lower 7\nbits of a second byte. If the value is above 0x3fff, the high bit is set and\nthe remaining 2 bits of the value are placed into the lower 2 bits of a third\nbyte.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/transactions",
        "title": "transactions",
        "content": "Account Address Format\u200bAn account address is 32-bytes of arbitrary data. When the address requires a\ndigital signature, the runtime interprets it as the public key of an ed25519\nkeypair.\nInstructions\u200bEach instruction specifies a single program, a\nsubset of the transaction's accounts that should be passed to the program, and a\ndata byte array that is passed to the program. The program interprets the data\narray and operates on the accounts specified by the instructions. The program\ncan return successfully, or with an error code. An error return causes the\nentire transaction to fail immediately.\nPrograms typically provide helper functions to construct instructions they\nsupport. For example, the system program provides the following Rust helper to\nconstruct a\nSystemInstruction::CreateAccount\ninstruction:pub fn create_account(    from_pubkey: &Pubkey,    to_pubkey: &Pubkey,    lamports: u64,    space: u64,    owner: &Pubkey,) -> Instruction {    let account_metas = vec!\n[        AccountMeta::new(*from_pubkey, true),        AccountMeta::new(*to_pubkey, true),    ];    Instruction::new_with_bincode(        system_program::id(),        &SystemInstruction::CreateAccount {            lamports,            space,            owner: *owner,        },        account_metas,    )}Which can be found here:https://github.\ncom/solana-labs/solana/blob/6606590b8132e56dab9e60b3f7d20ba7412a736c/sdk/program/src/system_instruction.\nrs#L220Program Id\u200bThe instruction's program id specifies which",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/transactions",
        "title": "transactions",
        "content": "program will process this instruction. The program's account's owner specifies\nwhich loader should be used to load and execute the program, and the data\ncontains information about how the runtime should execute the program.\nIn the case of on-chain BPF programs,\nthe owner is the BPF Loader and the account data holds the BPF bytecode. Program\naccounts are permanently marked as executable by the loader once they are\nsuccessfully deployed. The runtime will reject transactions that specify programs\nthat are not executable.\nUnlike on-chain programs, Native Programs\nare handled differently in that they are built directly into the Solana runtime.\nAccounts\u200bThe accounts referenced by an instruction represent on-chain state and serve as\nboth the inputs and outputs of a program. More information about accounts can be\nfound in the Accounts section.\nInstruction data\u200bEach instruction carries a general purpose byte array that is passed to the\nprogram along with the accounts. The contents of the instruction data is program\nspecific and typically used to convey what operations the program should\nperform, and any additional information those operations may need above and\nbeyond what the accounts contain.\nPrograms are free to specify how information is encoded into the instruction\ndata byte array. The choice of how data is encoded should consider the\noverhead of decoding, since that step is performed by the program on-chain. It's",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/transactions",
        "title": "transactions",
        "content": "been observed that some common encodings (Rust's bincode for example) are very\ninefficient.\nThe Solana Program Library's Token\nprogram\ngives one example of how instruction data can be encoded efficiently, but note\nthat this method only supports fixed sized types. Token utilizes the\nPack\ntrait to encode/decode instruction data for both token instructions as well as\ntoken account states.\nMultiple instructions in a single transaction\u200bA transaction can contain instructions in any order. This means a malicious\nuser could craft transactions that may pose instructions in an order that the\nprogram has not been protected against. Programs should be hardened to properly\nand safely handle any possible instruction sequence.\nOne not so obvious example is account deinitialization. Some programs may\nattempt to deinitialize an account by setting its lamports to zero, with the\nassumption that the runtime will delete the account. This assumption may be\nvalid between transactions, but it is not between instructions or cross-program\ninvocations. To harden against this, the program should also explicitly zero out the\naccount's data.\nAn example of where this could be a problem is if a token program, upon\ntransferring the token out of an account, sets the account's lamports to zero,\nassuming it will be deleted by the runtime. If the program does not zero out the\naccount's data, a malicious user could trail this instruction with another that\ntransfers the tokens a second time.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/programming-model/transactions",
        "title": "transactions",
        "content": "Signatures\u200bEach transaction explicitly lists all account public keys referenced by the\ntransaction's instructions. A subset of those public keys are each accompanied\nby a transaction signature. Those signatures signal on-chain programs that the\naccount holder has authorized the transaction. Typically, the program uses the\nauthorization to permit debiting the account or modifying its data. More\ninformation about how the authorization is communicated to a program can be\nfound in AccountsRecent Blockhash\u200bA transaction includes a recent blockhash to prevent\nduplication and to give transactions lifetimes. Any transaction that is\ncompletely identical to a previous one is rejected, so adding a newer blockhash\nallows multiple transactions to repeat the exact same action. Transactions also\nhave lifetimes that are defined by the blockhash, as any transaction whose\nblockhash is too old will be rejected.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/runtime-facilities/programs",
        "title": "programs",
        "content": "Native ProgramsSolana contains a small handful of native programs, which are required to run\nvalidator nodes. Unlike third-party programs, the native programs are part of\nthe validator implementation and can be upgraded as part of cluster upgrades.\nUpgrades may occur to add features, fix bugs, or improve performance. Interface\nchanges to individual instructions should rarely, if ever, occur. Instead, when\nchange is needed, new instructions are added and previous ones are marked\ndeprecated. Apps can upgrade on their own timeline without concern of breakages\nacross upgrades.\nFor each native program the program id and description each supported\ninstruction is provided. A transaction can mix and match instructions from different\nprograms, as well include instructions from on-chain programs.\nSystem Program\u200bCreate new accounts, allocate account data, assign accounts to owning programs,\ntransfer lamports from System Program owned accounts and pay transaction fees.\nProgram id: 11111111111111111111111111111111Instructions: SystemInstructionConfig Program\u200bAdd configuration data to the chain and the list of public keys that are permitted to modify itProgram id: Config1111111111111111111111111111111111111Instructions: config_instructionUnlike the other programs, the Config program does not define any individual\ninstructions. It has just one implicit instruction, a \"store\" instruction. Its\ninstruction data is a set of keys that gate access to the account, and the\ndata to store in it.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/runtime-facilities/programs",
        "title": "programs",
        "content": "Stake Program\u200bCreate and manage accounts representing stake and rewards for delegations to\nvalidators.\nProgram id: Stake11111111111111111111111111111111111111Instructions: StakeInstructionVote Program\u200bCreate and manage accounts that track validator voting state and rewards.\nProgram id: Vote111111111111111111111111111111111111111Instructions: VoteInstructionBPF Loader\u200bDeploys, upgrades, and executes programs on the chain.\nProgram id: BPFLoaderUpgradeab1e11111111111111111111111Instructions: LoaderInstructionThe BPF Upgradeable Loader marks itself as \"owner\" of the executable and\nprogram-data accounts it creates to store your program. When a user invokes an\ninstruction via a program id, the Solana runtime will load both your the program\nand its owner, the BPF Upgradeable Loader. The runtime then passes your program\nto the BPF Upgradeable Loader to process the instruction.\nMore information about deploymentEd25519 Program\u200bVerify ed25519 signature program. This program takes an ed25519 signature, public key, and message.\nMultiple signatures can be verified. If any of the signatures fail to verify, an error is returned.\nProgram id: Ed25519SigVerify111111111111111111111111111Instructions: new_ed25519_instructionThe ed25519 program processes an instruction. The first u8 is a count of the number of\nsignatures to check, which is followed by a single byte padding. After that, the\nfollowing struct is serialized, one for each signature to check.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/runtime-facilities/programs",
        "title": "programs",
        "content": "struct Ed25519SignatureOffsets {    signature_offset: u16,             // offset to ed25519 signature of 64 bytes    signature_instruction_index: u16,  // instruction index to find signature    public_key_offset: u16,            // offset to public key of 32 bytes    public_key_instruction_index: u16, // instruction index to find public key    message_data_offset: u16,          // offset to start of message data    message_data_size: u16,            // size of message data    message_instruction_index: u16,    // index of instruction data to get message data}Pseudo code of the operation:process_instruction() {    for i in 0.\n.\ncount {        // i'th index values referenced:        instructions = &transaction.\nmessage().\ninstructions        instruction_index = ed25519_signature_instruction_index !\n= u16::MAX ? ed25519_signature_instruction_index : current_instruction;        signature = instructions[instruction_index].\ndata[ed25519_signature_offset.\n.\ned25519_signature_offset + 64]        instruction_index = ed25519_pubkey_instruction_index !\n= u16::MAX ? ed25519_pubkey_instruction_index : current_instruction;        pubkey = instructions[instruction_index].\ndata[ed25519_pubkey_offset.\n.\ned25519_pubkey_offset + 32]        instruction_index = ed25519_message_instruction_index !\n= u16::MAX ? ed25519_message_instruction_index : current_instruction;        message = instructions[instruction_index].\ndata[ed25519_message_data_offset.\n.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/runtime-facilities/programs",
        "title": "programs",
        "content": "ed25519_message_data_offset + ed25519_message_data_size]        if pubkey.\nverify(signature, message) !\n= Success {            return Error        }    }    return Success}Secp256k1 Program\u200bVerify secp256k1 public key recovery operations (ecrecover).\nProgram id: KeccakSecp256k11111111111111111111111111111Instructions: new_secp256k1_instructionThe secp256k1 program processes an instruction which takes in as the first byte\na count of the following struct serialized in the instruction data:struct Secp256k1SignatureOffsets {    secp_signature_key_offset: u16,        // offset to [signature,recovery_id,etherum_address] of 64+1+20 bytes    secp_signature_instruction_index: u8,  // instruction index to find data    secp_pubkey_offset: u16,               // offset to [signature,recovery_id] of 64+1 bytes    secp_signature_instruction_index: u8,  // instruction index to find data    secp_message_data_offset: u16,         // offset to start of message data    secp_message_data_size: u16,           // size of message data    secp_message_instruction_index: u8,    // index of instruction data to get message data}Pseudo code of the operation:process_instruction() {  for i in 0.\n.\ncount {      // i'th index values referenced:      instructions = &transaction.\nmessage().\ninstructions      signature = instructions[secp_signature_instruction_index].\ndata[secp_signature_offset.\n.\nsecp_signature_offset + 64]      recovery_id = instructions[secp_signature_instruction_index].",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/runtime-facilities/programs",
        "title": "programs",
        "content": "data[secp_signature_offset + 64]      ref_eth_pubkey = instructions[secp_pubkey_instruction_index].\ndata[secp_pubkey_offset.\n.\nsecp_pubkey_offset + 32]      message_hash = keccak256(instructions[secp_message_instruction_index].\ndata[secp_message_data_offset.\n.\nsecp_message_data_offset + secp_message_data_size])      pubkey = ecrecover(signature, recovery_id, message_hash)      eth_pubkey = keccak256(pubkey[1.\n.\n])[12.\n.\n]      if eth_pubkey !\n= ref_eth_pubkey {          return Error      }  }  return Success}This allows the user to specify any instruction data in the transaction for\nsignature and message data. By specifying a special instructions sysvar, one can\nalso receive data from the transaction itself.\nCost of the transaction will count the number of signatures to verify multiplied\nby the signature cost verify multiplier.\nOptimization notes\u200bThe operation will have to take place after (at least partial) deserialization,\nbut all inputs come from the transaction data itself, this allows it to be\nrelatively easy to execute in parallel to transaction processing and PoH\nverification.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/runtime-facilities/sysvars",
        "title": "sysvars",
        "content": "Sysvar Cluster DataSolana exposes a variety of cluster state data to programs via\nsysvar accounts. These accounts are populated at\nknown addresses published along with the account layouts in the\nsolana-program\ncrate,\nand outlined below.\nThere are two ways for a program to access a sysvar.\nThe first is to query the sysvar at runtime via the sysvar's get() function:let clock = Clock::get()The following sysvars support get:ClockEpochScheduleFeesRentThe second is to pass the sysvar to the program as an account by including its address as one of the accounts in the Instruction and then deserializing the data during execution.  Access to sysvars accounts is\nalways readonly.\nlet clock_sysvar_info = next_account_info(account_info_iter)?\n;let clock = Clock::from_account_info(&clock_sysvar_info)?\n;The first method is more efficient and does not require that the sysvar account be passed to the program, or specified in the Instruction the program is processing.\nClock\u200bThe Clock sysvar contains data on cluster time, including the current slot,\nepoch, and estimated wall-clock Unix timestamp. It is updated every slot.\nAddress: SysvarC1ock11111111111111111111111111111111Layout: ClockFields:slot: the current slotepoch_start_timestamp: the Unix timestamp of the first slot in this epoch. In the first slot of an epoch, this timestamp is identical to the unix_timestamp (below).",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/runtime-facilities/sysvars",
        "title": "sysvars",
        "content": "epoch: the current epochleader_schedule_epoch: the most recent epoch for which the leader schedule has already been generatedunix_timestamp: the Unix timestamp of this slot.\nEach slot has an estimated duration based on Proof of History. But in reality,\nslots may elapse faster and slower than this estimate. As a result, the Unix\ntimestamp of a slot is generated based on oracle input from voting validators.\nThis timestamp is calculated as the stake-weighted median of timestamp\nestimates provided by votes, bounded by the expected time elapsed since the\nstart of the epoch.\nMore explicitly: for each slot, the most recent vote timestamp provided by\neach validator is used to generate a timestamp estimate for the current slot\n(the elapsed slots since the vote timestamp are assumed to be\nBank::ns_per_slot). Each timestamp estimate is associated with the stake\ndelegated to that vote account to create a distribution of timestamps by\nstake. The median timestamp is used as the unix_timestamp, unless the\nelapsed time since the epoch_start_timestamp has deviated from the expected\nelapsed time by more than 25%.\nEpochSchedule\u200bThe EpochSchedule sysvar contains epoch scheduling constants that are set in\ngenesis, and enables calculating the number of slots in a given epoch, the epoch\nfor a given slot, etc. (Note: the epoch schedule is distinct from the leader schedule)Address: SysvarEpochSchedu1e111111111111111111111111Layout:",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/runtime-facilities/sysvars",
        "title": "sysvars",
        "content": "EpochScheduleFees\u200bThe Fees sysvar contains the fee calculator for the current slot. It is updated\nevery slot, based on the fee-rate governor.\nAddress: SysvarFees111111111111111111111111111111111Layout:\nFeesInstructions\u200bThe Instructions sysvar contains the serialized instructions in a Message while\nthat Message is being processed. This allows program instructions to reference\nother instructions in the same transaction. Read more information on\ninstruction introspection.\nAddress: Sysvar1nstructions1111111111111111111111111Layout:\nInstructionsRecentBlockhashes\u200bThe RecentBlockhashes sysvar contains the active recent blockhashes as well as\ntheir associated fee calculators. It is updated every slot. Entries are ordered\nby descending block height, so the first entry holds the most recent block hash,\nand the last entry holds an old block hash.\nAddress: SysvarRecentB1ockHashes11111111111111111111Layout:\nRecentBlockhashesRent\u200bThe Rent sysvar contains the rental rate. Currently, the rate is static and set\nin genesis. The Rent burn percentage is modified by manual feature activation.\nAddress: SysvarRent111111111111111111111111111111111Layout:\nRentSlotHashes\u200bThe SlotHashes sysvar contains the most recent hashes of the slot's parent\nbanks. It is updated every slot.\nAddress: SysvarS1otHashes111111111111111111111111111Layout:\nSlotHashesSlotHistory\u200bThe SlotHistory sysvar contains a bitvector of slots present over the last\nepoch. It is updated every slot.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/runtime-facilities/sysvars",
        "title": "sysvars",
        "content": "Address: SysvarS1otHistory11111111111111111111111111Layout:\nSlotHistoryStakeHistory\u200bThe StakeHistory sysvar contains the history of cluster-wide stake activations\nand de-activations per epoch. It is updated at the start of every epoch.\nAddress: SysvarStakeHistory1111111111111111111111111Layout:\nStakeHistory",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/test-validator",
        "title": "test-validator",
        "content": "Solana Test ValidatorDuring early stage development, it is often convenient to target a cluster with\nfewer restrictions and more configuration options than the public offerings\nprovide. This is easily achieved with the solana-test-validator binary, which\nstarts a full-featured, single-node cluster on the developer's workstation.\nAdvantages\u200bNo RPC rate-limitsNo airdrop limitsDirect on-chain program deployment\n(--bpf-program .\n.\n.\n)Clone accounts from a public cluster, including programs (--clone .\n.\n.\n)Load accounts from filesConfigurable transaction history retention (--limit-ledger-size .\n.\n.\n)Configurable epoch length (--slots-per-epoch .\n.\n.\n)Jump to an arbitrary slot (--warp-slot .\n.\n.\n)Installation\u200bThe solana-test-validator binary ships with the Solana CLI Tool Suite.\nInstall before continuing.\nRunning\u200bFirst take a look at the configuration optionssolana-test-validator --helpNext start the test validatorsolana-test-validatorBy default, basic status information is printed while the process is running.\nSee Appendix I for detailsLedger location: test-ledgerLog: test-ledger/validator.\nlogIdentity: EPhgPANa5Rh2wa4V2jxt7YbtWa3Uyw4sTeZ13cQjDDB8Genesis Hash: 4754oPEMhAKy14CZc8GzQUP93CB4ouELyaTs4P8ittYnVersion: 1.\n6.\n7Shred Version: 13286Gossip Address: 127.\n0.\n0.\n1:1024TPU Address: 127.\n0.\n0.\n1:1027JSON RPC URL: http://127.\n0.\n0.\n1:8899\u2808 00:36:02 | Processed Slot: 5142 | Confirmed Slot: 5142 | Finalized Slot: 5110 | Snapshot Slot: 5100 | Transactions: 5142 | \u25ce499.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/test-validator",
        "title": "test-validator",
        "content": "974295000Leave solana-test-validator running in its own terminal. When it is no longer\nneeded, it can be stopped with ctrl-c.\nInteracting\u200bOpen a new terminal to interact with a running solana-test-validator\ninstance using other binaries from the Solana CLI Tool Suite or your own client\nsoftware.\nConfigure the CLI Tool Suite to target a local cluster by default\u200bsolana config set --url http://127.\n0.\n0.\n1:8899Verify the CLI Tool Suite configuration\u200bsolana genesis-hashNOTE: The result should match the Genesis Hash: field in the\nsolana-test-validator status outputCheck the wallet balance\u200bsolana balanceNOTE: Error: No such file or directory (os error 2) means that the default\nwallet does not yet exist. Create it with solana-keygen new.\nNOTE: If the wallet has a zero SOL balance, airdrop some localnet SOL with\nsolana airdrop 10Perform a basic transfer transaction\u200bsolana transfer EPhgPANa5Rh2wa4V2jxt7YbtWa3Uyw4sTeZ13cQjDDB8 1Monitor msg!\n() output from on-chain programs\u200bsolana logsNOTE: This command needs to be running when the target transaction is\nexecuted. Run it in its own terminalAppendix I: Status Output\u200bLedger location: test-ledgerFile path of the ledger storage directory. This directory can get large. Store\nless transaction history with --limit-ledger-size .\n.\n. or relocate it with\n--ledger .\n.\n.\nLog: test-ledger/validator.\nlogFile path of the validator text log file. The log can also be streamed by\npassing --log. Status output is suppressed in this case.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/test-validator",
        "title": "test-validator",
        "content": "Identity: EPhgPANa5Rh2wa4V2jxt7YbtWa3Uyw4sTeZ13cQjDDB8The validator's identity in the gossip networkVersion: 1.\n6.\n7The software versionGossip Address: 127.\n0.\n0.\n1:1024TPU Address: 127.\n0.\n0.\n1:1027JSON RPC URL: http://127.\n0.\n0.\n1:8899The network address of the Gossip,\nTransaction Processing Unit and JSON RPC\nservice, respectively\u2808 00:36:02 | Processed Slot: 5142 | Confirmed Slot: 5142 | Finalized Slot: 5110 | Snapshot Slot: 5100 | Transactions: 5142 | \u25ce499.\n974295000Session running time, current slot of the the three block\ncommitment levels,\nslot height of the last snapshot, transaction count,\nvoting authority balanceAppendix II: Runtime Features\u200bBy default, the test validator runs with all runtime features activated.\nYou can verify this using the Solana command-line tools:solana feature status -ulSince this may not always be desired, especially when testing programs meant for deployment to mainnet, the CLI provides an option to deactivate specific features:solana-test-validator --deactivate-feature <FEATURE_PUBKEY_1> --deactivate-feature <FEATURE_PUBKEY_2>",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/versioned-transactions",
        "title": "versioned-transactions",
        "content": "Versioned TransactionsVersioned Transactions are the new transaction format that allow for additional functionality in the Solana runtime, including Address Lookup Tables.\nWhile changes to on chain programs are NOT required to support the new functionality of versioned transactions (or for backwards compatibility), developers WILL need update their client side code to prevent errors due to different transaction versions.\nCurrent Transaction Versions\u200bThe Solana runtime supports two transaction versions:legacy - older transaction format with no additional benefit0 - added support for Address Lookup TablesMax supported transaction version\u200bAll RPC requests that return a transaction should specify the highest version of transactions they will support in their application using the maxSupportedTransactionVersion option, including getBlock and getTransaction.\nAn RPC request will fail if a Versioned Transaction is returned that is higher than the set maxSupportedTransactionVersion. (i.\ne. if a version 0 transaction is returned when legacy is selected)WARNING:\nIf no maxSupportedTransactionVersion value is set, then only legacy transactions will be allowed in the RPC response. Therefore, your RPC requests WILL fail if any version 0 transactions are returned.\nHow to set max supported version\u200bYou can set the maxSupportedTransactionVersion using both the @solana/web3.\njs library and JSON formatted requests directly to an RPC endpoint.\nUsing web3.\njs\u200bUsing the @solana/web3.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/versioned-transactions",
        "title": "versioned-transactions",
        "content": "js library, you can retrieve the most recent block or get a specific transaction:// connect to the `devnet` cluster and get the current `slot`const connection = new web3.\nConnection(web3.\nclusterApiUrl(\"devnet\"));const slot = await connection.\ngetSlot();// get the latest block (allowing for v0 transactions)const block = await connection.\ngetBlock(slot, {  maxSupportedTransactionVersion: 0,});// get a specific transaction (allowing for v0 transactions)const getTx = await connection.\ngetTransaction(  \"3jpoANiFeVGisWRY5UP648xRXs3iQasCHABPWRWnoEjeA93nc79WrnGgpgazjq4K9m8g2NJoyKoWBV1Kx5VmtwHQ\",  {    maxSupportedTransactionVersion: 0,  },);JSON requests to the RPC\u200bUsing a standard JSON formatted POST request, you can set the maxSupportedTransactionVersion when retrieving a specific block:curl http://localhost:8899 -X POST -H \"Content-Type: application/json\" -d \\'{\"jsonrpc\": \"2.\n0\", \"id\":1, \"method\": \"getBlock\", \"params\": [430, {  \"encoding\":\"json\",  \"maxSupportedTransactionVersion\":0,  \"transactionDetails\":\"full\",  \"rewards\":false}]}'How create a Versioned Transaction\u200bVersioned transactions can be created similar to the older method of creating transactions. There are differences in using certain libraries that should be noted.\nBelow is an example of how to create a Versioned Transaction, using the @solana/web3.\njs library, to send perform a SOL transfer between two accounts.\nNotes:\u200bpayer is a valid Keypair wallet, funded with SOLtoAccount a valid KeypairFirstly, import the web3.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/versioned-transactions",
        "title": "versioned-transactions",
        "content": "js library and create a connection to your desired cluster.\nWe then define the recent blockhash and minRent we will need for our transaction and the account.\nconst web3 = require(\"@solana/web3.\njs\");// connect to the cluster and get the minimum rent for rent exempt statusconst connection = new web3.\nConnection(web3.\nclusterApiUrl(\"devnet\"));let minRent = await connection.\ngetMinimumBalanceForRentExemption(0);let blockhash = await connection  .\ngetLatestBlockhash()  .\nthen((res) => res.\nblockhash);Create an array of all the instructions you desire to send in your transaction. In this example below, we are creating a simple SOL transfer instruction:// create an array with your desires `instructions`const instructions = [  web3.\nSystemProgram.\ntransfer({    fromPubkey: payer.\npublicKey,    toPubkey: toAccount.\npublicKey,    lamports: minRent,  }),];Next, construct a MessageV0 formatted transaction message with your desired instructions:// create v0 compatible messageconst messageV0 = new web3.\nTransactionMessage({  payerKey: payer.\npublicKey,  recentBlockhash: blockhash,  instructions,}).\ncompileToV0Message();Then, create a new VersionedTransaction, passing in our v0 compatible message:const transaction = new web3.\nVersionedTransaction(messageV0);// sign your transaction with the required `Signers`transaction.\nsign([payer]);You can sign the transaction by either:passing an array of signatures into the VersionedTransaction method, orcall the transaction.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/developing/versioned-transactions",
        "title": "versioned-transactions",
        "content": "sign() method, passing an array of the required SignersNOTE:\nAfter calling the transaction.\nsign() method, all the previous transaction signatures will be fully replaced by new signatures created from the provided in Signers.\nAfter your VersionedTransaction has been signed by all required accounts, you can send it to the cluster and await the response.\n// send our v0 transaction to the clusterconst txid = await connection.\nsendTransaction(transaction);console.\nlog(`https://explorer.\nsolana.\ncom/tx/${txid}?\ncluster=devnet`);NOTE:\nUnlike legacy transactions, sending a VersionedTransaction via sendTransaction does NOT support transaction signing via passing in an array of Signers as the second parameter. You will need to sign the transaction before calling connection.\nsendTransaction().\nMore Resources\u200busing Versioned Transactions for Address Lookup Tablesview an example of a v0 transaction on Solana Explorerread the accepted proposal for Versioned Transaction and Address Lookup Tables",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/getstarted/hello-world",
        "title": "hello-world",
        "content": "Hello World Quickstart GuideFor this \"hello world\" quickstart guide, we will use Solana Playground, a browser the based IDE, to develop and deploy our Solana program. To use it, you do NOT have to install any software on your computer. Simply open Solana Playground in your browser of choice, and you are ready to write and deploy Solana programs.\nWhat you will learn\u200bHow to get started with Solana PlaygroundHow to create a Solana wallet on PlaygroundHow to program a basic Solana program in RustHow to build and deploy a Solana Rust programHow to interact with your on chain program using JavaScriptUsing Solana Playground\u200bSolana Playground is browser based application that will let you write, build, and deploy on chain Solana programs. All from your browser. No installation needed.\nIt is a great developer resource for getting started with Solana development, especially on Windows.\nImport our example project\u200bIn a new tab in your browser, open our example \"Hello World\" project on Solana Playground: https://beta.\nsolpg.\nio/6314a69688a7fca897ad7d1dNext, import the project into your local workspace by clicking the \"Import\" icon and naming your project hello_world.\nIf you do not import the program into your Solana Playground, then you will not be able to make changes to the code. But you will still be able to build and deploy the code to a Solana cluster.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/getstarted/hello-world",
        "title": "hello-world",
        "content": "Create a Playground wallet\u200bNormally with local development, you will need to create a file system wallet for use with the Solana CLI. But with the Solana Playground, you only need to click a few buttons to create a browser based wallet.\ncautionYour Playground Wallet will be saved in your browser's local storage. Clearing your browser cache will remove your saved wallet. When creating a new wallet, you will have the option to save a local copy of your wallet's keypair file.\nClick on the red status indicator button at the bottom left of the screen, (optionally) save your wallet's keypair file to your computer for backup, then click \"Continue\".\nAfter your Playground Wallet is created, you will notice the bottom of the window now states your wallet's address, your SOL balance, and the Solana cluster you are connected to (Devnet is usually the default/recommended, but a \"localhost\" test validator is also acceptable).\nCreate a Solana program\u200bThe code for your Rust based Solana program will live in your src/lib.\nrs file. Inside src/lib.\nrs you will be able to import your Rust crates and define your logic. Open your src/lib.\nrs file within Solana Playground.\nImport the solana_program crate\u200bAt the top of lib.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/getstarted/hello-world",
        "title": "hello-world",
        "content": "rs, we import the solana-program crate and bring our needed items into the local namespace:use solana_program::{    account_info::AccountInfo,    entrypoint,    entrypoint::ProgramResult,    pubkey::Pubkey,    msg,};Write your program logic\u200bEvery Solana program must define an entrypoint that tells the Solana runtime where to start executing your on chain code. Your program's entrypoint should provide a public function named process_instruction:// declare and export the program's entrypointentrypoint!\n(process_instruction);// program entrypoint's implementationpub fn process_instruction(    program_id: &Pubkey,    accounts: &[AccountInfo],    instruction_data: &[u8]) -> ProgramResult {    // log a message to the blockchain    msg!\n(\"Hello, world!\n\");    // gracefully exit the program    Ok(())}Every on chain program should return the Ok result enum with a value of (). This tells the Solana runtime that your program executed successfully without errors.\nOur program above will simply log a message of \"Hello, world!\n\" to the blockchain cluster, then gracefully exit with Ok(()).\nBuild your program\u200bOn the left sidebar, select the \"Build & Deploy\" tab. Next, click the \"Build\" button.\nIf you look at the Playground's terminal, you should see your Solana program begin to compile. Once complete, you will see a success message.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/getstarted/hello-world",
        "title": "hello-world",
        "content": "cautionYou may receive warning when your program is compiled due to unused variables. Don't worry, these warning will not affect your build. They are due to our very simple program not using all the variables we declared in the process_instruction function.\nDeploy your program\u200bYou can click the \"Deploy\" button to deploy your first program to the Solana blockchain. Specifically to your selected cluster (e.\ng. Devnet, Testnet, etc).\nAfter each deployment, you will see your Playground Wallet balance change. By default, Solana Playground will automatically request SOL airdrops on your behalf to ensure your wallet has enough SOL to cover the cost of deployment.\nNote:\nIf you need more SOL, you can airdrop more by typing airdrop command in the playground terminal:solana airdrop 2Find your program id\u200bWhen executing a program using web3.\njs or from another Solana program, you will need to provide the program id (aka public address of your program).\nInside Solana Playground's Build & Deploy sidebar, you can find your program id under the Program Credentials dropdown.\nCongratulations!\n\u200bYou have successfully setup, built, and deployed a Solana program using the Rust language directly in your browser. Next, we will demonstrate how to interact with your on chain program.\nInteract with your on chain program\u200bOnce you have successfully deployed a Solana program to the blockchain, you will want to be able to interact with that program.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/getstarted/hello-world",
        "title": "hello-world",
        "content": "Like most developers creating dApps and websites, we will interact with our on chain program using JavaScript. Specifically, will use the open source NPM package @solana/web3.\njs to aid in our client application.\ninfoThis web3.\njs package is an abstraction layer on top of the JSON RPC API that reduced the need for rewriting common boilerplate, helping to simplify your client side application code.\nInitialize client\u200bWe will be using Solana Playground for the client generation. Create a client folder by running run command in the playground terminal:runWe have created client folder and a default client.\nts. This is where we will work for the rest of our hello world program.\nPlayground globals\u200bIn playground, there are many utilities that are globally available for us to use without installing or setting up anything. Most important ones for our hello world program are web3 for @solana/web3.\njs and pg for Solana Playground utilities.\ninfoYou can go over all of the available globals by pressing CTRL+SPACE (or CMD+SPACE on macOS) inside the editor.\nCall the program\u200bTo execute your on chain program, you must send a transaction to it. Each transaction submitted to the Solana blockchain contains a listing of instructions (and the program's that instruction will interact with).\nHere we create a new transaction and add a single instruction to it:// create an empty transactionconst transaction = new web3.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/getstarted/hello-world",
        "title": "hello-world",
        "content": "Transaction();// add a hello world program instruction to the transactiontransaction.\nadd(  new web3.\nTransactionInstruction({    keys: [],    programId: new web3.\nPublicKey(pg.\nPROGRAM_ID),  }),);Each instruction must include all the keys involved in the operation and the program ID we want to execute. In this example keys is empty because our program only logs hello world and doesn't need any accounts.\nWith our transaction created, we can submit it to the cluster:// send the transaction to the Solana clusterconsole.\nlog(\"Sending transaction.\n.\n.\n\");const txHash = await web3.\nsendAndConfirmTransaction(  pg.\nconnection,  transaction,  [pg.\nwallet.\nkeypair],);console.\nlog(\"Transaction sent with hash:\", txHash);infoThe first signer in the signers array is the transaction fee payer by default. We are signing with our keypair pg.\nwallet.\nkeypair.\nRun the application\u200bWith the client application written, you can run the code via the same run command.\nOnce your application completes, you will see output similar to this:Running client.\n.\n.  client.\nts:    My address: GkxZRRNPfaUfL9XdYVfKF3rWjMcj5md6b6mpRoWpURwP    My balance: 5.\n7254472 SOL    Sending transaction.\n.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/getstarted/hello-world",
        "title": "hello-world",
        "content": ".    Transaction sent with hash: 2Ra7D9JoqeNsax9HmNq6MB4qWtKPGcLwoqQ27mPYsPFh3h8wignvKB2mWZVvdzCyTnp7CEZhfg2cEpbavib9mCcqGet transaction logs\u200bWe will be using solana-cli directly in playground to get the information about any transaction:solana confirm -v <TRANSACTION_HASH>Change <TRANSACTION_HASH> with the hash you received from calling hello world program.\nYou should see Hello, world! in the Log Messages section of the output. \ud83c\udf89Congratulations!\n!\n!\n\u200bYou have now written a client application for your on chain program. You are now a Solana developer!\nPS: Try to update your program's message then re-build, re-deploy, and re-execute your program.\nNext steps\u200bSee the links below to learn more about writing Solana programs:Setup your local development environmentOverview of writing Solana programsLearn more about developing Solana programs with RustDebugging on chain programs",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/getstarted/local",
        "title": "local",
        "content": "Local Development QuickstartThis quickstart guide will demonstrate how to quickly install and setup your local development environment, getting you ready to start developing and deploying Solana programs to the blockchain.\nWhat you will learn\u200bHow to install the Solana CLI locallyHow to setup a localhost Solana cluster/validatorHow to create a Solana wallet for developingHow to airdrop SOL tokens for your walletInstall the Solana CLI\u200bTo interact with the Solana clusters from your terminal, install the Solana CLI tool suite on your local system:sh -c \"$(curl -sSfL https://release.\nsolana.\ncom/stable/install)\"Setup a localhost blockchain cluster\u200bThe Solana CLI comes with the test validator built in. This command line tool will allow you to run a full blockchain cluster on your machine.\nsolana-test-validatorPRO TIP:\nRun the Solana test validator in a new/separate terminal window that will remain open. The command line program must remain running for your localhost cluster to remain online and ready for action.\nConfigure your Solana CLI to use your localhost validator for all your future terminal commands:solana config set --url localhostAt any time, you can view your current Solana CLI configuration settings:solana config getCreate a file system wallet\u200bTo deploy a program with Solana CLI, you will need a Solana wallet with SOL tokens to pay for the cost of transactions.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/getstarted/local",
        "title": "local",
        "content": "Let's create a simple file system wallet for testing:solana-keygen newBy default, the solana-keygen command will create a new file system wallet located at ~/.\nconfig/solana/id.\njson. You can manually specify the output file location using the --outfile /path option.\nNOTE:\nIf you already have a file system wallet saved at the default location, this command will NOT override it (unless you explicitly force override using the --force flag).\nSet your new wallet as default\u200bWith your new file system wallet created, you must tell the Solana CLI to use this wallet to deploy and take ownership of your on chain program:solana config set -k ~/.\nconfig/solana/id.\njsonAirdrop SOL tokens to your wallet\u200bOnce your new wallet is set as the default, you can request a free airdrop of SOL tokens to it:solana airdrop 2NOTE:\nThe solana airdrop command has a limit of how many SOL tokens can be requested per airdrop for each cluster (localhost, testnet, or devent). If your airdrop transaction fails, lower your airdrop request quantity and try again.\nYou can check your current wallet's SOL balance any time:solana balanceNext steps\u200bSee the links below to learn more about writing Rust based Solana programs:Create and deploy a Solana Rust programOverview of writing Solana programs",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/getstarted/rust",
        "title": "rust",
        "content": "Rust Program QuickstartRust is the most common programming language to write Solana programs with. This quickstart guide will demonstrate how to quickly setup, build, and deploy your first Rust based Solana program to the blockchain.\nNOTE: \nThis guide uses the Solana CLI and assumes you have setup your local development environment. Checkout our local development quickstart guide here to quickly get setup.\nWhat you will learn\u200bHow to install the Rust language locallyHow to initialize a new Solana Rust programHow to code a basic Solana program in RustHow to build and deploy your Rust programInstall Rust and Cargo\u200bTo be able to compile Rust based Solana programs, install the Rust language and Cargo (the Rust package manager) using Rustup:curl --proto '=https' --tlsv1.\n2 -sSf https://sh.\nrustup.\nrs | shRun your localhost validator\u200bThe Solana CLI comes with the test validator built in. This command line tool will allow you to run a full blockchain cluster on your machine.\nsolana-test-validatorPRO TIP:\nRun the Solana test validator in a new/separate terminal window that will remain open. This command line program must remain running for your localhost validator to remain online and ready for action.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/getstarted/rust",
        "title": "rust",
        "content": "Configure your Solana CLI to use your localhost validator for all your future terminal commands and Solana program deployment:solana config set --url localhostCreate a new Rust library with Cargo\u200bSolana programs written in Rust are libraries which are compiled to BPF bytecode and saved in the .\nso format.\nInitialize a new Rust library named hello_world via the Cargo command line:cargo init hello_world --libcd hello_worldAdd the solana-program crate to your new Rust library:cargo add solana-programOpen your Cargo.\ntoml file and add these required Rust library configuration settings, updating your project name as appropriate:[lib]name = \"hello_world\"crate-type = [\"cdylib\", \"lib\"]Create your first Solana program\u200bThe code for your Rust based Solana program will live in your src/lib.\nrs file. Inside src/lib.\nrs you will be able to import your Rust crates and define your logic. Open your src/lib.\nrs file in your favorite editor.\nAt the top of lib.\nrs, import the solana-program crate and bring our needed items into the local namespace:use solana_program::{    account_info::AccountInfo,    entrypoint,    entrypoint::ProgramResult,    pubkey::Pubkey,    msg,};Every Solana program must define an entrypoint that tells the Solana runtime where to start executing your on chain code. Your program's entrypoint should provide a public function named process_instruction:// declare and export the program's entrypointentrypoint!",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/getstarted/rust",
        "title": "rust",
        "content": "(process_instruction);// program entrypoint's implementationpub fn process_instruction(    program_id: &Pubkey,    accounts: &[AccountInfo],    instruction_data: &[u8]) -> ProgramResult {    // log a message to the blockchain    msg!\n(\"Hello, world!\n\");    // gracefully exit the program    Ok(())}Every on chain program should return the Ok result enum with a value of (). This tells the Solana runtime that your program executed successfully without errors.\nThis program above will simply log a message of \"Hello, world!\n\" to the blockchain cluster, then gracefully exit with Ok(()).\nBuild your Rust program\u200bInside a terminal window, you can build your Solana Rust program by running in the root of your project (i.\ne. the directory with your Cargo.\ntoml file):cargo build-bpfNOTE:\nAfter each time you build your Solana program, the above command will output the build path of your compiled program's .\nso file and the default keyfile that will be used for the program's address.\nDeploy your Solana program\u200bUsing the Solana CLI, you can deploy your program to your currently selected cluster:solana program deploy .\n/target/deploy/hello_world.\nsoOnce your Solana program has been deployed (and the transaction finalized), the above command will output your program's public address (aka its \"program id\").\n# example outputProgram Id: EFH95fWg49vkFNbAdw9vy75tM7sWZ2hQbTTUmuACGip3Congratulations!\n\u200bYou have successfully setup, built, and deployed a Solana program using the Rust language.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/getstarted/rust",
        "title": "rust",
        "content": "PS: Check your Solana wallet's balance again after you deployed. See how much SOL it cost to deploy your simple program?\nNext steps\u200bSee the links below to learn more about writing Rust based Solana programs:Overview of writing Solana programsLearn more about developing Solana programs with RustDebugging on chain programs",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/learn/state-compression",
        "title": "state-compression",
        "content": "State CompressionOn Solana, State Compression is the method of creating\na \"fingerprint\" (or hash) of off-chain data and storing this fingerprint\non-chain for secure verification. Effectively using the security of the Solana\nledger to securely validate off-chain data, verifying it has not been tampered\nwith.\nThis method of \"compression\" allows Solana programs and dApps to use cheap\nblockchain ledger space, instead of the more\nexpensive account space, to securely store data.\nThis is accomplished by using a special binary tree structure, known as a\nconcurrent merkle tree, to create a hash of\neach piece of data (called a leaf), hashing those together, and only storing\nthis final hash on-chain.\nWhat is State Compression?\n\u200bIn simple terms, state compression uses \"tree\" structures to\ncryptographically hash off-chain data together, in a deterministic way, to\ncompute a single final hash that gets stored on-chain.\nThese trees are created in this \"deterministic\" process by:taking any piece of datacreating a hash of this datastoring this hash as a leaf the bottom of the treeeach leaf pair is then hash together, creating a brancheach branch is then hash togethercontinually climbing the tree and hashing adjacent branches togetheronce at the top of the tree, a final root hash is producedThis root hash is then stored on chain, as a verifiable proof of all of\nthe data within every leaf. Allowing anyone to cryptographically verify all the",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/learn/state-compression",
        "title": "state-compression",
        "content": "off-chain data within the tree, while only actually storing a minimal amount\nof data on-chain. Therefore, significantly reducing the cost to store/prove\nlarge amounts of data due to this \"state compression\".\nMerkle trees and concurrent merkle trees\u200bSolana's state compression used a special type of\nmerkle tree that allows for multiple changes to any\ngiven tree to happen, while still maintaining the integrity and validity of the\ntree.\nThis special tree, known as a\n\"concurrent merkle tree\", effectively\nretains a \"changelog\" of the tree on-chain. Allowing for multiple rapid changes\nto the same tree (i.\ne. all in the same block), before a proof is invalidated.\nWhat is a merkle tree?\n\u200bA merkle tree, sometimes called a\n\"hash tree\", is a hash based binary tree structure where each leaf node is\nrepresented as a cryptographic hash of its inner data. And every node that is\nnot a leaf, called a branch, is represented as a hash of its child leaf\nhashes.\nEach branch is then also hashed together, climbing the tree, until eventually\nonly a single hash remains. This final hash, called the root hash or \"root\",\ncan then be used in combination with a \"proof path\" to verify any piece of data\nstored within a leaf node.\nOnce a final root hash has been computed, any piece of data stored within a\nleaf node can be verified by rehashing the specific leaf's data and the hash\nlabel of each adjacent branch climbing the tree (known as the proof or \"proof",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/learn/state-compression",
        "title": "state-compression",
        "content": "path\"). Comparing this \"rehash\" to the root hash is the verification of the\nunderlying leaf data. If they match, the data is verified accurate. If they do\nnot match, the leaf data was changed.\nWhenever desired, the original leaf data can be changed by simply hashing the\nnew leaf data and recomputing the root hash in the same manner of the\noriginal root. This new root hash is then used to verify any of the data,\nand effectively invalidates the previous root hash and previous proof.\nTherefore, each change to these traditional merkle trees are required to be\nperformed in series.\ninfoThis process of changing leaf data, and computing a new root hash can be a\nvery common thing when using merkle trees! While it is one of the design\npoints of the tree, it can result in one of the most notable drawbacks: rapid\nchanges.\nWhat is a Concurrent merkle tree?\n\u200bIn high throughput applications, like within the\nSolana runtime, requests to change an on-chain\ntraditional merkle tree could be received by validators in relatively rapid\nsuccession (e.\ng. within the same slot). Each leaf data change would still be\nrequired to performed in series. Resulting in each subsequent request for change\nto fail, due to the root hash and proof being invalidated by the previous change\nrequest in the slot.\nEnter, Concurrent merkle trees.\nA Concurrent merkle tree stores a secure changelog of the most recent\nchanges, their root hash, and the proof to derive it. This changelog \"buffer\" is",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/learn/state-compression",
        "title": "state-compression",
        "content": "stored on-chain in an account specific to each tree, with a maximum number of\nchangelog \"records\" (aka maxBufferSize).\nWhen multiple leaf data change requests are received by validators in the same\nslot, the on-chain concurrent merkle tree can use this \"changelog buffer\" as a\nsource of truth for more acceptable proofs. Effectively allowing for up to\nmaxBufferSize changes to the same tree in the same slot. Significantly\nboosting throughput.\nSizing a concurrent merkle tree\u200bWhen creating one of these on-chain trees, there are 3 values that will\ndetermine the size of your tree, the cost to create your tree, and the number of\nconcurrent changes to your tree:max depthmax buffer sizecanopy depthMax depth\u200bThe \"max depth\" of a tree is the maximum number of hops to get from any data\nleaf to the root of the tree.\nSince merkle trees are binary trees, every leaf is connected to only one\nother leaf; existing as a leaf pair.\nTherefore, the maxDepth of a tree is used to determine the maximum number of\nnodes (aka pieces of data or leafs) to store within the tree using a simple\ncalculation:nodes_count = 2 ^ maxDepthSince a trees depth must be set at tree creation, you must decide how many\npieces of data you want your tree to store. Then using the simple calculation\nabove, you can determine the lowest maxDepth to store your data.\nExample 1: minting 100 nfts\u200bIf you wanted to create a tree to store 100 compressed nfts, we will need a\nminimum of \"100 leafs\" or \"100 nodes\".",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/learn/state-compression",
        "title": "state-compression",
        "content": "// maxDepth=6 -> 64 nodes2^6 = 64// maxDepth=7 -> 128 nodes2^7 = 128We must use a maxDepth of 7 to ensure we can store all of our data.\nExample 2: minting 15000 nfts\u200bIf you wanted to create a tree to store 15000 compressed nfts, we will need a\nminimum of \"15000 leafs\" or \"15000 nodes\".\n// maxDepth=13 -> 8192 nodes2^13 = 8192// maxDepth=14 -> 16384 nodes2^14 = 16384We must use a maxDepth of 14 to ensure we can store all of our data.\nThe higher the max depth, the higher the cost\u200bThe maxDepth value will be one of the primary drivers of cost when creating a\ntree since you will pay this cost upfront at tree creation. The higher the max\ntree depth depth, the more data fingerprints (aka hashes) you can store, the\nhigher the cost.\nMax buffer size\u200bThe \"max buffer size\" is effectively the maximum number of changes that can\noccur on a tree, with the root hash still being valid.\nDue to the root hash effectively being a single hash of all leaf data, changing\nany single leaf would invalidate the proof needed for all subsequent attempts to\nchange any leaf of a regular tree.\nBut with a concurrent tree, there is\neffectively a changelog of updates for these proofs. This changelog buffer is\nsized and set at tree creation via this maxBufferSize value.\nCanopy depth\u200bThe \"canopy depth\", sometimes called the canopy size, is the number of proof\nnodes that are cached/stored on-chain for any given proof path.\nWhen performing an update action on a leaf, like transferring ownership (e.\ng.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/learn/state-compression",
        "title": "state-compression",
        "content": "selling a compressed NFT), the complete proof path must be used to verify\noriginal ownership of the leaf and therefore allow for the update action. This\nverification is performed using the complete proof path to correctly compute\nthe current root hash (or any cached root hash via the on-chain \"concurrent\nbuffer\").\nThe larger a tree's max depth is, the more proof nodes are required to perform\nthis verification. For example, if your max depth is 14, there are 14 total\nproof nodes required to be used to verify. As a tree gets larger, the complete\nproof path gets larger.\nNormally, each of these proof nodes would be required to be included within each\ntree update transaction. Since each proof node value takes up 32 bytes in a\ntransaction (similar to providing a Public Key), larger trees would very quickly\nexceed the maximum transaction size limit.\nEnter the canopy. The canopy enables storing a set number of proof nodes on\nchain (for any given proof path). Allowing for less proof nodes to be included\nwithin each update transactions, therefore keeping the overall transaction size\nbelow the limit.\nFor example, a tree with a max depth of 14 would require 14 total proof\nnodes. With a canopy of 10, only 4 proof nodes are required to be submitted\nper update transaction.\nThe larger the canopy depth value, the higher the cost\u200bThe canopyDepth value is also a primary factor of cost when creating a tree\nsince you will pay this cost upfront at tree creation. The higher the canopy",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/learn/state-compression",
        "title": "state-compression",
        "content": "depth, the more data proof nodes are stored on chain, the higher the cost.\nSmaller canopy limits composability\u200bWhile a tree's creation costs are higher with a higher canopy, having a lower\ncanopyDepth will require more proof nodes to be included within each update\ntransaction. The more nodes required to be submitted, the larger the transaction\nsize, and therefore the easier it is to exceed the transaction size limits.\nThis will also be the case for any other Solana program or dApp that attempts to\ninteract with your tree/leafs. If your tree requires too many proof nodes\n(because of a low canopy depth), then any other additional actions another\non-chain program could offer will be limited by their specific\ninstruction size plus your proof node list size. Limiting composability, and\npotential additional utility for your specific tree.\nFor example, if your tree is being used for compressed NFTs and has a very low\ncanopy depth, an NFT marketplace may only be able to support simple NFTs\ntransfers. And not be able to support an on-chain bidding system.\nCost of creating a tree\u200bThe cost of creating a concurrent merkle tree is based on the tree's size\nparameters: maxDepth, maxBufferSize, and canopyDepth. These values are all\nused to calculate the on-chain storage (in bytes) required for a tree to exist\non chain.\nOnce the required space (in bytes) has been calculated, and using the\ngetMinimumBalanceForRentExemption",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/learn/state-compression",
        "title": "state-compression",
        "content": "RPC method, request the cost (in lamports) to allocate this amount of bytes\non-chain.\nCalculate tree cost in JavaScript\u200bWithin the\n@solana/spl-account-compression\npackage, developers can use the\ngetConcurrentMerkleTreeAccountSize\nfunction to calculate the required space for a given tree size parameters.\nThen using the\ngetMinimumBalanceForRentExemption\nfunction to get the final cost (in lamports) to allocate the required space for\nthe tree on-chain.\nThen determine the cost in lamports to make an account of this size rent exempt,\nsimilar to any other account creation.\n// calculate the space required for the treeconst requiredSpace = getConcurrentMerkleTreeAccountSize(  maxDepth,  maxBufferSize,  canopyDepth,);// get the cost (in lamports) to store the tree on-chainconst storageCost = await connection.\ngetMinimumBalanceForRentExemption(  requiredSpace,);Example costs\u200bListed below are several example costs, for different tree sizes, including how\nmany leaf nodes are possible for each:Example #1: 16,384 nodes costing 0.\n222 SOLmax depth of 14 and max buffer size of 64maximum number of leaf nodes: 16,384canopy depth of 0 costs approximately 0.\n222 SOL to createExample #2: 16,384 nodes costing 1.\n134 SOLmax depth of 14 and max buffer size of 64maximum number of leaf nodes: 16,384canopy depth of 11 costs approximately 1.\n134 SOL to createExample #3: 1,048,576 nodes costing 1.",
        "type": "content"
    },
    {
        "link": "https://docs.solana.com/learn/state-compression",
        "title": "state-compression",
        "content": "673 SOLmax depth of 20 and max buffer size of 256maximum number of leaf nodes: 1,048,576canopy depth of 10 costs approximately 1.\n673 SOL to createExample #4: 1,048,576 nodes costing 15.\n814 SOLmax depth of 20 and max buffer size of 256maximum number of leaf nodes: 1,048,576canopy depth of 15 costs approximately 15.\n814 SOL to createCompressed NFTs\u200bCompressed NFTs are one of the most popular use cases for State Compression on\nSolana. With compression, a one million NFT collection could be minted for\n~50 SOL, vice ~12,000 SOL for its uncompressed equivalent collection.\nDeveloper GuideRead our developer guide for\nminting and transferring compressed NFTs.",
        "type": "content"
    }
]